<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.01.03</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__ParallelGroup.html">Parallelization</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A distributed object (Charm++ Chare) that executes a series of Actions and is capable of sending and receiving data. Acts as an interface to Charm++.  
 <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#details">More...</a></p>

<p><code>#include &lt;Algorithm.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a438fdac4fe98dcd6065044723bf92a70"><td class="memItemLeft" align="right" valign="top"><a id="a438fdac4fe98dcd6065044723bf92a70" name="a438fdac4fe98dcd6065044723bf92a70"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>all_actions_list</b> = tmpl::flatten&lt; tmpl::list&lt; typename PhaseDepActionListsPack::action_list... &gt; &gt;</td></tr>
<tr class="memdesc:a438fdac4fe98dcd6065044723bf92a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Actions in the order that generates the DataBox types. <br /></td></tr>
<tr class="separator:a438fdac4fe98dcd6065044723bf92a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a2834097ddf905967ba31c22a90e0"><td class="memItemLeft" align="right" valign="top"><a id="af89a2834097ddf905967ba31c22a90e0" name="af89a2834097ddf905967ba31c22a90e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>metavariables</b> = typename ParallelComponent::metavariables</td></tr>
<tr class="memdesc:af89a2834097ddf905967ba31c22a90e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The metavariables class passed to the Algorithm. <br /></td></tr>
<tr class="separator:af89a2834097ddf905967ba31c22a90e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd172a93f8d3edfe16bd8e7fb39dd87"><td class="memItemLeft" align="right" valign="top"><a id="addd172a93f8d3edfe16bd8e7fb39dd87" name="addd172a93f8d3edfe16bd8e7fb39dd87"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inbox_tags_list</b> = <a class="el" href="group__ParallelGroup.html#gae918917e798cb6dd36a6cca9ede77616">Parallel::get_inbox_tags</a>&lt; <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a438fdac4fe98dcd6065044723bf92a70">all_actions_list</a> &gt;</td></tr>
<tr class="memdesc:addd172a93f8d3edfe16bd8e7fb39dd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">List off all the Tags that can be received into the Inbox. <br /></td></tr>
<tr class="separator:addd172a93f8d3edfe16bd8e7fb39dd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37aca050edd797bef91fbefa9d6554"><td class="memItemLeft" align="right" valign="top"><a id="ace37aca050edd797bef91fbefa9d6554" name="ace37aca050edd797bef91fbefa9d6554"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>array_index</b> = typename get_array_index&lt; typename ParallelComponent::chare_type &gt;::template f&lt; ParallelComponent &gt;</td></tr>
<tr class="memdesc:ace37aca050edd797bef91fbefa9d6554"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the object used to identify the element of the array, group or nodegroup spatially. The default should be an <code>int</code>. <br /></td></tr>
<tr class="separator:ace37aca050edd797bef91fbefa9d6554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36166bfa7a3bba2c59c45d250b8f3b1"><td class="memItemLeft" align="right" valign="top"><a id="af36166bfa7a3bba2c59c45d250b8f3b1" name="af36166bfa7a3bba2c59c45d250b8f3b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>parallel_component</b> = ParallelComponent</td></tr>
<tr class="separator:af36166bfa7a3bba2c59c45d250b8f3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3f2fb4548bda189a6cfcb79ffee0cb"><td class="memItemLeft" align="right" valign="top"><a id="a8d3f2fb4548bda189a6cfcb79ffee0cb" name="a8d3f2fb4548bda189a6cfcb79ffee0cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>chare_type</b> = typename parallel_component::chare_type</td></tr>
<tr class="memdesc:a8d3f2fb4548bda189a6cfcb79ffee0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the Chare. <br /></td></tr>
<tr class="separator:a8d3f2fb4548bda189a6cfcb79ffee0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a277e0c80fedb79af37b58db031845a"><td class="memItemLeft" align="right" valign="top"><a id="a9a277e0c80fedb79af37b58db031845a" name="a9a277e0c80fedb79af37b58db031845a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cproxy_type</b> = typename chare_type::template cproxy&lt; parallel_component, <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ace37aca050edd797bef91fbefa9d6554">array_index</a> &gt;</td></tr>
<tr class="memdesc:a9a277e0c80fedb79af37b58db031845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Charm++ proxy object type. <br /></td></tr>
<tr class="separator:a9a277e0c80fedb79af37b58db031845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bada73164509a0d287fc77946f1d63"><td class="memItemLeft" align="right" valign="top"><a id="a86bada73164509a0d287fc77946f1d63" name="a86bada73164509a0d287fc77946f1d63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cbase_type</b> = typename chare_type::template cbase&lt; parallel_component, <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ace37aca050edd797bef91fbefa9d6554">array_index</a> &gt;</td></tr>
<tr class="memdesc:a86bada73164509a0d287fc77946f1d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Charm++ base object type. <br /></td></tr>
<tr class="separator:a86bada73164509a0d287fc77946f1d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe617de21f9c1c33b81521149e6349e"><td class="memItemLeft" align="right" valign="top"><a id="a3fe617de21f9c1c33b81521149e6349e" name="a3fe617de21f9c1c33b81521149e6349e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseType</b> = typename tmpl::front&lt; tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::phase_type</td></tr>
<tr class="memdesc:a3fe617de21f9c1c33b81521149e6349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the phases. <br /></td></tr>
<tr class="separator:a3fe617de21f9c1c33b81521149e6349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdce81aa528292c141b988d96b73c68c"><td class="memItemLeft" align="right" valign="top"><a id="abdce81aa528292c141b988d96b73c68c" name="abdce81aa528292c141b988d96b73c68c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>phase_dependent_action_lists</b> = tmpl::list&lt; PhaseDepActionListsPack... &gt;</td></tr>
<tr class="separator:abdce81aa528292c141b988d96b73c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a4dac5ff8d030622896d75248052c7"><td class="memItemLeft" align="right" valign="top"><a id="a16a4dac5ff8d030622896d75248052c7" name="a16a4dac5ff8d030622896d75248052c7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>databox_types</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; databox_phase_types, get_databox_types&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:a16a4dac5ff8d030622896d75248052c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a838161018b0d9bf3d7526352ec1b25fc"><td class="memTemplParams" colspan="2"><a id="a838161018b0d9bf3d7526352ec1b25fc" name="a838161018b0d9bf3d7526352ec1b25fc"></a>
template&lt;class... InitializationTags&gt; </td></tr>
<tr class="memitem:a838161018b0d9bf3d7526352ec1b25fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlgorithmImpl</b> (const Parallel::CProxy_GlobalCache&lt; <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#af89a2834097ddf905967ba31c22a90e0">metavariables</a> &gt; &amp;global_cache_proxy, <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; InitializationTags... &gt; initialization_items)</td></tr>
<tr class="memdesc:a838161018b0d9bf3d7526352ec1b25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor used by <a class="el" href="classParallel_1_1Main.html" title="The main function of a Charm++ executable. See the Parallelization documentation for an overview of M...">Main</a> to initialize the algorithm. <br /></td></tr>
<tr class="separator:a838161018b0d9bf3d7526352ec1b25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f3776ade6b7cca41794d00b2b5aef5"><td class="memItemLeft" align="right" valign="top"><a id="a54f3776ade6b7cca41794d00b2b5aef5" name="a54f3776ade6b7cca41794d00b2b5aef5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AlgorithmImpl</b> (CkMigrateMessage *)</td></tr>
<tr class="memdesc:a54f3776ade6b7cca41794d00b2b5aef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ migration constructor, used after a chare is migrated. <br /></td></tr>
<tr class="separator:a54f3776ade6b7cca41794d00b2b5aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2dac11e2c65556df0a2b46517a5846"><td class="memItemLeft" align="right" valign="top"><a id="a1d2dac11e2c65556df0a2b46517a5846" name="a1d2dac11e2c65556df0a2b46517a5846"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>print_types</b> () const</td></tr>
<tr class="memdesc:a1d2dac11e2c65556df0a2b46517a5846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the expanded type aliases. <br /></td></tr>
<tr class="separator:a1d2dac11e2c65556df0a2b46517a5846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ddf0a78bcc3049562e86a56b80f57d"><td class="memItemLeft" align="right" valign="top"><a id="a22ddf0a78bcc3049562e86a56b80f57d" name="a22ddf0a78bcc3049562e86a56b80f57d"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>print_state</b> () const</td></tr>
<tr class="memdesc:a22ddf0a78bcc3049562e86a56b80f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current state of the algorithm. <br /></td></tr>
<tr class="separator:a22ddf0a78bcc3049562e86a56b80f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f22c8604d96e8261425a3ae2c777a7"><td class="memItemLeft" align="right" valign="top"><a id="aa2f22c8604d96e8261425a3ae2c777a7" name="aa2f22c8604d96e8261425a3ae2c777a7"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>print_inbox</b> () const</td></tr>
<tr class="memdesc:aa2f22c8604d96e8261425a3ae2c777a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current contents of the inboxes. <br /></td></tr>
<tr class="separator:aa2f22c8604d96e8261425a3ae2c777a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af993aee006c1ea9d598d70613d64a962"><td class="memItemLeft" align="right" valign="top"><a id="af993aee006c1ea9d598d70613d64a962" name="af993aee006c1ea9d598d70613d64a962"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>print_databox</b> () const</td></tr>
<tr class="memdesc:af993aee006c1ea9d598d70613d64a962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current contents of the DataBox. <br /></td></tr>
<tr class="separator:af993aee006c1ea9d598d70613d64a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755e9834e408edc725a3fe7387519f38"><td class="memItemLeft" align="right" valign="top"><a id="a755e9834e408edc725a3fe7387519f38" name="a755e9834e408edc725a3fe7387519f38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pup</b> (PUP::er &amp;p) override</td></tr>
<tr class="separator:a755e9834e408edc725a3fe7387519f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77578c2c0c771cb9fe8a769005684e43"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename Arg &gt; </td></tr>
<tr class="memitem:a77578c2c0c771cb9fe8a769005684e43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a77578c2c0c771cb9fe8a769005684e43">reduction_action</a> (Arg arg)</td></tr>
<tr class="memdesc:a77578c2c0c771cb9fe8a769005684e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <code>apply</code> function <code>Action</code> after a reduction has been completed.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a77578c2c0c771cb9fe8a769005684e43">More...</a><br /></td></tr>
<tr class="separator:a77578c2c0c771cb9fe8a769005684e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139f820b9fcff21c72eba9b90d1a51e"><td class="memTemplParams" colspan="2"><a id="ac139f820b9fcff21c72eba9b90d1a51e" name="ac139f820b9fcff21c72eba9b90d1a51e"></a>
template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ac139f820b9fcff21c72eba9b90d1a51e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_action</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; args)</td></tr>
<tr class="memdesc:ac139f820b9fcff21c72eba9b90d1a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly call the action <code>Action</code>. If the returned DataBox type is not one of the types of the algorithm then a compilation error occurs. <br /></td></tr>
<tr class="separator:ac139f820b9fcff21c72eba9b90d1a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0687619435fae9c74eb67fa32bc9b9"><td class="memTemplParams" colspan="2"><a id="a6e0687619435fae9c74eb67fa32bc9b9" name="a6e0687619435fae9c74eb67fa32bc9b9"></a>
template&lt;typename Action &gt; </td></tr>
<tr class="memitem:a6e0687619435fae9c74eb67fa32bc9b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_action</b> ()</td></tr>
<tr class="separator:a6e0687619435fae9c74eb67fa32bc9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030cbeaada7a7a78334d51ad1e9b5cad"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a030cbeaada7a7a78334d51ad1e9b5cad"><td class="memTemplItemLeft" align="right" valign="top">Action::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a030cbeaada7a7a78334d51ad1e9b5cad">local_synchronous_action</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a030cbeaada7a7a78334d51ad1e9b5cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <code>Action</code> sychronously, returning a result without any parallelization. The action is called immediately and control flow returns to the caller immediately upon completion.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a030cbeaada7a7a78334d51ad1e9b5cad">More...</a><br /></td></tr>
<tr class="separator:a030cbeaada7a7a78334d51ad1e9b5cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7232b9f569f9a9cb490d36c37cc550a"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename ReceiveDataType &gt; </td></tr>
<tr class="memitem:ab7232b9f569f9a9cb490d36c37cc550a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ab7232b9f569f9a9cb490d36c37cc550a">receive_data</a> (typename ReceiveTag::temporal_id instance, ReceiveDataType &amp;&amp;t, bool enable_if_disabled=false)</td></tr>
<tr class="memdesc:ab7232b9f569f9a9cb490d36c37cc550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data and store it in the Inbox, and try to continue executing the algorithm.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ab7232b9f569f9a9cb490d36c37cc550a">More...</a><br /></td></tr>
<tr class="separator:ab7232b9f569f9a9cb490d36c37cc550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461bb42bc527e4c928f0c1110c23001"><td class="memItemLeft" align="right" valign="top"><a id="ad461bb42bc527e4c928f0c1110c23001" name="ad461bb42bc527e4c928f0c1110c23001"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>start_phase</b> (const <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a3fe617de21f9c1c33b81521149e6349e">PhaseType</a> next_phase)</td></tr>
<tr class="memdesc:ad461bb42bc527e4c928f0c1110c23001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start execution of the phase-dependent action list in <code>next_phase</code>. If <code>next_phase</code> has already been visited, execution will resume at the point where the previous execution of the same phase left off. <br /></td></tr>
<tr class="separator:ad461bb42bc527e4c928f0c1110c23001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c568f139c08e042593ae251f026cee2"><td class="memItemLeft" align="right" valign="top"><a id="a5c568f139c08e042593ae251f026cee2" name="a5c568f139c08e042593ae251f026cee2"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>set_terminate</b> (const bool t)</td></tr>
<tr class="memdesc:a5c568f139c08e042593ae251f026cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the Algorithm it should no longer execute the algorithm. This does not mean that the execution of the program is terminated, but only that the algorithm has terminated. An algorithm can be restarted by passing <code>true</code> as the second argument to the <code>receive_data</code> method or by calling perform_algorithm(true). <br /></td></tr>
<tr class="separator:a5c568f139c08e042593ae251f026cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5f01dd7cdcc9e359eba58cb3babf4b"><td class="memItemLeft" align="right" valign="top"><a id="adb5f01dd7cdcc9e359eba58cb3babf4b" name="adb5f01dd7cdcc9e359eba58cb3babf4b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_terminate</b> () const</td></tr>
<tr class="memdesc:adb5f01dd7cdcc9e359eba58cb3babf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an algorithm should continue being evaluated. <br /></td></tr>
<tr class="separator:adb5f01dd7cdcc9e359eba58cb3babf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2fcc184b9cd7218d0a57267ecd15e96e"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args, <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;(sizeof...(Args), std::is_same_v&lt; <a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html">Parallel::Algorithms::Nodegroup</a>, <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a8d3f2fb4548bda189a6cfcb79ffee0cb">chare_type</a> &gt;)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a2fcc184b9cd7218d0a57267ecd15e96e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a2fcc184b9cd7218d0a57267ecd15e96e">threaded_action</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; args)</td></tr>
<tr class="memdesc:a2fcc184b9cd7218d0a57267ecd15e96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an Action on a local nodegroup requiring the Action to handle thread safety.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a2fcc184b9cd7218d0a57267ecd15e96e">More...</a><br /></td></tr>
<tr class="separator:a2fcc184b9cd7218d0a57267ecd15e96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5940d918bfed5403dff84d738fb21f5b"><td class="memTemplParams" colspan="2">template&lt;typename Action &gt; </td></tr>
<tr class="memitem:a5940d918bfed5403dff84d738fb21f5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a5940d918bfed5403dff84d738fb21f5b">threaded_action</a> ()</td></tr>
<tr class="memdesc:a5940d918bfed5403dff84d738fb21f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an Action on a local nodegroup requiring the Action to handle thread safety.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a5940d918bfed5403dff84d738fb21f5b">More...</a><br /></td></tr>
<tr class="separator:a5940d918bfed5403dff84d738fb21f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5aeff4d9ae8c55df31994de2bfec798c"><td class="memItemLeft" align="right" valign="top"><a id="a5aeff4d9ae8c55df31994de2bfec798c" name="a5aeff4d9ae8c55df31994de2bfec798c"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>perform_algorithm</b> ()</td></tr>
<tr class="memdesc:a5aeff4d9ae8c55df31994de2bfec798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start evaluating the algorithm until it is stopped by an action. <br /></td></tr>
<tr class="separator:a5aeff4d9ae8c55df31994de2bfec798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfacd966295cce498a681a2ac38a975"><td class="memItemLeft" align="right" valign="top"><a id="a7bfacd966295cce498a681a2ac38a975" name="a7bfacd966295cce498a681a2ac38a975"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>perform_algorithm</b> (const bool restart_if_terminated)</td></tr>
<tr class="memdesc:a7bfacd966295cce498a681a2ac38a975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start evaluating the algorithm until it is stopped by an action. <br /></td></tr>
<tr class="separator:a7bfacd966295cce498a681a2ac38a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3bbd5cd529154e65724ec39e4653697"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ab3bbd5cd529154e65724ec39e4653697">number_of_procs</a> () const</td></tr>
<tr class="memdesc:ab3bbd5cd529154e65724ec39e4653697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers for charm++ informational functions.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ab3bbd5cd529154e65724ec39e4653697">More...</a><br /></td></tr>
<tr class="separator:ab3bbd5cd529154e65724ec39e4653697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57aa7fe745cbb4c2d01e906649081e"><td class="memItemLeft" align="right" valign="top"><a id="aed57aa7fe745cbb4c2d01e906649081e" name="aed57aa7fe745cbb4c2d01e906649081e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>my_proc</b> () const</td></tr>
<tr class="memdesc:aed57aa7fe745cbb4c2d01e906649081e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:aed57aa7fe745cbb4c2d01e906649081e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2f4296fd5c50bd6b9f826808d765f"><td class="memItemLeft" align="right" valign="top"><a id="a02d2f4296fd5c50bd6b9f826808d765f" name="a02d2f4296fd5c50bd6b9f826808d765f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>number_of_nodes</b> () const</td></tr>
<tr class="memdesc:a02d2f4296fd5c50bd6b9f826808d765f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:a02d2f4296fd5c50bd6b9f826808d765f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914e0a726649fe5e7d55c0a19d4433e4"><td class="memItemLeft" align="right" valign="top"><a id="a914e0a726649fe5e7d55c0a19d4433e4" name="a914e0a726649fe5e7d55c0a19d4433e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>my_node</b> () const</td></tr>
<tr class="memdesc:a914e0a726649fe5e7d55c0a19d4433e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:a914e0a726649fe5e7d55c0a19d4433e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33621505c62d20609ba2b2566848ac79"><td class="memItemLeft" align="right" valign="top"><a id="a33621505c62d20609ba2b2566848ac79" name="a33621505c62d20609ba2b2566848ac79"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>procs_on_node</b> (const int node_index) const</td></tr>
<tr class="memdesc:a33621505c62d20609ba2b2566848ac79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:a33621505c62d20609ba2b2566848ac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704964b7b0159ba27f013a750d12ae96"><td class="memItemLeft" align="right" valign="top"><a id="a704964b7b0159ba27f013a750d12ae96" name="a704964b7b0159ba27f013a750d12ae96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>my_local_rank</b> () const</td></tr>
<tr class="memdesc:a704964b7b0159ba27f013a750d12ae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:a704964b7b0159ba27f013a750d12ae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b235786ae73e1af3d731021788f6ab"><td class="memItemLeft" align="right" valign="top"><a id="aa3b235786ae73e1af3d731021788f6ab" name="aa3b235786ae73e1af3d731021788f6ab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>first_proc_on_node</b> (const int node_index) const</td></tr>
<tr class="memdesc:aa3b235786ae73e1af3d731021788f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:aa3b235786ae73e1af3d731021788f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdaf8b534b2a5c30b87a22e27fded1d"><td class="memItemLeft" align="right" valign="top"><a id="accdaf8b534b2a5c30b87a22e27fded1d" name="accdaf8b534b2a5c30b87a22e27fded1d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>node_of</b> (const int proc_index) const</td></tr>
<tr class="memdesc:accdaf8b534b2a5c30b87a22e27fded1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:accdaf8b534b2a5c30b87a22e27fded1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51076502bb47db5ef33626d5ce229a"><td class="memItemLeft" align="right" valign="top"><a id="abf51076502bb47db5ef33626d5ce229a" name="abf51076502bb47db5ef33626d5ce229a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>local_rank_of</b> (const int proc_index) const</td></tr>
<tr class="memdesc:abf51076502bb47db5ef33626d5ce229a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:abf51076502bb47db5ef33626d5ce229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ParallelComponent, typename... PhaseDepActionListsPack&gt;<br />
class Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;</div><p >A distributed object (Charm++ Chare) that executes a series of Actions and is capable of sending and receiving data. Acts as an interface to Charm++. </p>
<h3><a class="anchor" id="autotoc_md269"></a>
Different Types of Algorithms</h3>
<p >Charm++ chares can be one of four types, which is specified by the type alias <code>chare_type</code> inside the <code>ParallelComponent</code>. The four available types of Algorithms are:</p><ol type="1">
<li>A <a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html" title="A struct that stores the charm++ types relevant for a particular singleton component.">Parallel::Algorithms::Singleton</a> where there is only one in the entire execution of the program.</li>
<li>A <a class="el" href="structParallel_1_1Algorithms_1_1Array.html" title="A struct that stores the charm++ types relevant for a particular array component.">Parallel::Algorithms::Array</a> which holds zero or more elements each of which is a distributed object on some core. An array can grow and shrink in size dynamically if need be and can also be bound to another array. That is, the bound array has the same number of elements as the array it is bound to, and elements with the same ID are on the same core.</li>
<li>A <a class="el" href="structParallel_1_1Algorithms_1_1Group.html" title="A struct that stores the charm++ types relevant for a particular group component.">Parallel::Algorithms::Group</a>, which is an array but there is one element per core and they are not able to be moved around between cores. These are typically useful for gathering data from array elements on their core, and then processing or reducing it.</li>
<li>A <a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html" title="A struct that stores the charm++ types relevant for a particular nodegroup component.">Parallel::Algorithms::Nodegroup</a>, which is similar to a group except that there is one element per node. For Charm++ SMP (shared memory parallelism) builds a node corresponds to the usual definition of a node on a supercomputer. However, for non-SMP builds nodes and cores are equivalent. An important difference between groups and nodegroups is that entry methods (remote calls to functions) are not threadsafe on nodegroups. It is up to the person writing the Actions that will be executed on the Nodegroup Algorithm to ensure they are threadsafe.</li>
</ol>
<h3><a class="anchor" id="autotoc_md270"></a>
What is an Algorithm?</h3>
<p >An Algorithm is a distributed object, a Charm++ chare, that repeatedly executes a series of Actions. An Action is a struct that has a <code>static</code> apply function with signature:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... DbTags, <span class="keyword">typename</span>... InboxTags, <span class="keyword">typename</span> Metavariables,</div>
<div class="line"><span class="keyword">typename</span> ArrayIndex,  <span class="keyword">typename</span> ActionList&gt;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">auto</span>  <a class="code hl_function" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a>(db::DataBox&lt;tmpl::list&lt;DbTags...&gt;&gt;&amp; box,</div>
<div class="line">                   <a class="code hl_class" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;InboxTags...&gt;</a>&amp; inboxes,</div>
<div class="line">                   <span class="keyword">const</span> GlobalCache&lt;Metavariables&gt;&amp; cache,</div>
<div class="line">                   <span class="keyword">const</span> ArrayIndex&amp; <a class="code hl_typedef" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ace37aca050edd797bef91fbefa9d6554">array_index</a>,</div>
<div class="line">                   <span class="keyword">const</span> TemporalId&amp; temporal_id, <span class="keyword">const</span> ActionList meta);</div>
<div class="ttc" id="aclassParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4_html_ace37aca050edd797bef91fbefa9d6554"><div class="ttname"><a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#ace37aca050edd797bef91fbefa9d6554">Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::array_index</a></div><div class="ttdeci">typename get_array_index&lt; typename ParallelComponent::chare_type &gt;::template f&lt; ParallelComponent &gt; array_index</div><div class="ttdoc">The type of the object used to identify the element of the array, group or nodegroup spatially....</div><div class="ttdef"><b>Definition:</b> Algorithm.hpp:169</div></div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:259</div></div>
<div class="ttc" id="agroup__DataStructuresGroup_html_ga058ade0497757606713948256728c6db"><div class="ttname"><a href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db">apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;f, const ObservationBox&lt; ComputeTagsList, DataBoxType &gt; &amp;observation_box, Args &amp;&amp;... args)</div><div class="ttdoc">Apply the function object f using its nested argument_tags list of tags.</div><div class="ttdef"><b>Definition:</b> ObservationBox.hpp:171</div></div>
</div><!-- fragment --><p >Note that any of the arguments can be const or non-const references except <code>array_index</code>, which must be a <code>const&amp;</code>.</p>
<h3><a class="anchor" id="autotoc_md271"></a>
Explicit instantiations of entry methods</h3>
<p >The code in src/Parallel/CharmMain.tpp registers all entry methods, and if one is not properly registered then a static_assert explains how to have it be registered. If there is a bug in the implementation and an entry method isn't being registered or hitting a static_assert then Charm++ will give an error of the following form:</p>
<pre class="fragment">* registration happened after init Entry point: simple_action(), addr:
* 0x555a3d0e2090
* ------------- Processor 0 Exiting: Called CmiAbort ------------
* Reason: Did you forget to instantiate a templated entry method in a .ci file?
* </pre><p >If you encounter this issue please file a bug report supplying everything necessary to reproduce the issue. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a030cbeaada7a7a78334d51ad1e9b5cad" name="a030cbeaada7a7a78334d51ad1e9b5cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030cbeaada7a7a78334d51ad1e9b5cad">&#9670;&nbsp;</a></span>local_synchronous_action()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Action::return_type Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::local_synchronous_action </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the <code>Action</code> sychronously, returning a result without any parallelization. The action is called immediately and control flow returns to the caller immediately upon completion. </p>
<dl class="section note"><dt>Note</dt><dd><code>Action</code> must have a type alias <code>return_type</code> specifying its return type. This constraint is to simplify the variant visitation logic for the <a class="el" href="group__DataBoxGroup.html">DataBox</a>. </dd></dl>

</div>
</div>
<a id="ab3bbd5cd529154e65724ec39e4653697" name="ab3bbd5cd529154e65724ec39e4653697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bbd5cd529154e65724ec39e4653697">&#9670;&nbsp;</a></span>number_of_procs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::number_of_procs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrappers for charm++ informational functions. </p>
<p >Number of processing elements </p>

</div>
</div>
<a id="ab7232b9f569f9a9cb490d36c37cc550a" name="ab7232b9f569f9a9cb490d36c37cc550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7232b9f569f9a9cb490d36c37cc550a">&#9670;&nbsp;</a></span>receive_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<div class="memtemplate">
template&lt;typename ReceiveTag , typename ReceiveDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::receive_data </td>
          <td>(</td>
          <td class="paramtype">typename ReceiveTag::temporal_id&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReceiveDataType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_if_disabled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data and store it in the Inbox, and try to continue executing the algorithm. </p>
<p >When an algorithm has terminated it can be restarted by passing <code>enable_if_disabled = true</code>. This allows long-term disabling and re-enabling of algorithms </p>

</div>
</div>
<a id="a77578c2c0c771cb9fe8a769005684e43" name="a77578c2c0c771cb9fe8a769005684e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77578c2c0c771cb9fe8a769005684e43">&#9670;&nbsp;</a></span>reduction_action()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::reduction_action </td>
          <td>(</td>
          <td class="paramtype">Arg&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the <code>apply</code> function <code>Action</code> after a reduction has been completed. </p>
<p >The <code>apply</code> function must take <code>arg</code> as its last argument. </p>

</div>
</div>
<a id="a5940d918bfed5403dff84d738fb21f5b" name="a5940d918bfed5403dff84d738fb21f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5940d918bfed5403dff84d738fb21f5b">&#9670;&nbsp;</a></span>threaded_action() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<div class="memtemplate">
template&lt;typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::threaded_action </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an Action on a local nodegroup requiring the Action to handle thread safety. </p>
<p >The <code><a class="el" href="classParallel_1_1NodeLock.html" title="A typesafe wrapper for a lock for synchronization of shared resources on a given node,...">Parallel::NodeLock</a></code> of the nodegroup is passed to the Action instead of the <code>action_list</code> as a <code>const <a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;<a class="el" href="classParallel_1_1NodeLock.html" title="A typesafe wrapper for a lock for synchronization of shared resources on a given node,...">Parallel::NodeLock</a>*&gt;&amp;</code>. The node lock can be locked with the <code>Parallel::NodeLock::lock()</code> function, and unlocked with <code>Parallel::unlock()</code>. <code>Parallel::NodeLock::try_lock()</code> is also provided in case something useful can be done if the lock couldn't be acquired. </p>

</div>
</div>
<a id="a2fcc184b9cd7218d0a57267ecd15e96e" name="a2fcc184b9cd7218d0a57267ecd15e96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcc184b9cd7218d0a57267ecd15e96e">&#9670;&nbsp;</a></span>threaded_action() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponent , typename... PhaseDepActionListsPack&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args, <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt;(sizeof...(Args), std::is_same_v&lt; <a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html">Parallel::Algorithms::Nodegroup</a>, <a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#a8d3f2fb4548bda189a6cfcb79ffee0cb">chare_type</a> &gt;)&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;::threaded_action </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call an Action on a local nodegroup requiring the Action to handle thread safety. </p>
<p >The <code><a class="el" href="classParallel_1_1NodeLock.html" title="A typesafe wrapper for a lock for synchronization of shared resources on a given node,...">Parallel::NodeLock</a></code> of the nodegroup is passed to the Action instead of the <code>action_list</code> as a <code>const <a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;<a class="el" href="classParallel_1_1NodeLock.html" title="A typesafe wrapper for a lock for synchronization of shared resources on a given node,...">Parallel::NodeLock</a>*&gt;&amp;</code>. The node lock can be locked with the <code>Parallel::NodeLock::lock()</code> function, and unlocked with <code>Parallel::unlock()</code>. <code>Parallel::NodeLock::try_lock()</code> is also provided in case something useful can be done if the lock couldn't be acquired. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Parallel/Algorithm.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceParallel.html">Parallel</a></li><li class="navelem"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html">AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
