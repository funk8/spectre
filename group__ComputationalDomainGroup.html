<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Computational Domain</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.01.03</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ComputationalDomainGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Computational Domain</div></div>
</div><!--header-->
<div class="contents">

<p>The building blocks used to describe the computational domain.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceamr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamr.html">amr</a></td></tr>
<tr class="memdesc:namespaceamr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Items for adaptive mesh refinement. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1BoundaryConditions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1BoundaryConditions.html">domain::BoundaryConditions</a></td></tr>
<tr class="memdesc:namespacedomain_1_1BoundaryConditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain support for applying boundary conditions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1CoordinateMaps_1_1Tags.html">domain::CoordinateMaps::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the coordinate maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators.html">domain::creators</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines classes that create Domains. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators_1_1time__dependence"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators_1_1time__dependence.html">domain::creators::time_dependence</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators_1_1time__dependence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and functions for adding time dependence to a domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1FunctionsOfTime"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1FunctionsOfTime.html">domain::FunctionsOfTime</a></td></tr>
<tr class="memdesc:namespacedomain_1_1FunctionsOfTime"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions of time to support the dual frame system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1Tags"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1Tags.html">domain::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlock.html">Block&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root node of a tree which is used to construct the Elements that cover a region of the computational domain.  <a href="classBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1CoordinateMaps_1_1Tags_1_1CoordinateMap.html">domain::CoordinateMaps::Tags::CoordinateMap&lt; VolumeDim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate map from source to target coordinates.  <a href="structdomain_1_1CoordinateMaps_1_1Tags_1_1CoordinateMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1creators_1_1BinaryCompactObject.html">domain::creators::BinaryCompactObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general domain for two compact objects.  <a href="classdomain_1_1creators_1_1BinaryCompactObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1creators_1_1CylindricalBinaryCompactObject.html">domain::creators::CylindricalBinaryCompactObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general domain for two compact objects based on cylinders.  <a href="classdomain_1_1creators_1_1CylindricalBinaryCompactObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomainCreator.html">DomainCreator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for creating Domains from an option string.  <a href="classDomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html">Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a vector of Blocks that represent the computational domain.  <a href="classDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPairOfFaces.html">PairOfFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each member in <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> holds the global corner ids of a block face. <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> is used in setting up periodic boundary conditions by identifying the two faces with each other.  <a href="structPairOfFaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVolumeCornerIterator.html">VolumeCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the corners of a VolumeDim-dimensional cube.  <a href="classVolumeCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaceCornerIterator.html">FaceCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the 2^(VolumeDim-1) logical corners of the face of a VolumeDim-dimensional cube in the given direction.  <a href="classFaceCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds element logical coordinates of an arbitrary set of points on a single <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>. The arbitrary set of points is assumed to be a subset of a larger set of points spanning multiple <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s, and this class holds <code>offsets</code> that index into that larger set of points.  <a href="structElementLogicalCoordHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementMap.html">ElementMap&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMap for the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> from the Logical frame to the <code>TargetFrame</code>  <a href="classElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html">domain::Tags::UnnormalizedFaceNormal&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unnormalized face normal one form.  <a href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_0184ce0938d30efe351cc7c3751f2e8f00.html">domain::Tags::InterfaceCompute&lt; Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;, UnnormalizedFaceNormalCompute&lt; VolumeDim, Frame &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html" title="The unnormalized face normal one form.">UnnormalizedFaceNormal</a> for the external boundaries which inverts the normals. Since ExternalBoundariesDirections are meant to represent ghost elements, the normals should correspond to the normals in said element, which are inverted with respect to the current element.  <a href="structdomain_1_1Tags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_0184ce0938d30efe351cc7c3751f2e8f00.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="namespacedomain_1_1FunctionsOfTime.html" title="Contains functions of time to support the dual frame system.">FunctionsOfTime</a>.  <a href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Actions_1_1CheckFunctionsOfTimeAreReady.html">domain::Actions::CheckFunctionsOfTimeAreReady</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that functions of time are up-to-date.  <a href="structdomain_1_1Actions_1_1CheckFunctionsOfTimeAreReady.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html">domain::FunctionsOfTime::PiecewisePolynomial&lt; MaxDeriv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that has a piecewise-constant <code>MaxDeriv</code>th derivative.  <a href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1QuaternionFunctionOfTime.html">domain::FunctionsOfTime::QuaternionFunctionOfTime&lt; MaxDeriv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html" title="Base class for FunctionsOfTime.">FunctionOfTime</a> that stores quaternions for the rotation map.  <a href="classdomain_1_1FunctionsOfTime_1_1QuaternionFunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html">domain::Tags::InterfaceCompute&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing items computed on a set of interfaces. Can be retrieved using <code><a class="el" href="structdomain_1_1Tags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;DirectionsTag, Tag&gt;</code>  <a href="structdomain_1_1Tags_1_1InterfaceCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Slice.html">domain::Tags::Slice&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing a compute item that slices data from the volume to a set of interfaces.  <a href="structdomain_1_1Tags_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceMesh.html">domain::Tags::InterfaceMesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>VolumeDim-1</code> dimensional mesh on an interface from the volume mesh. <code><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html" title="Compute tag for representing items computed on a set of interfaces. Can be retrieved using Tags::Inte...">Tags::InterfaceCompute</a>&lt;Dirs, <a class="el" href="structdomain_1_1Tags_1_1InterfaceMesh.html" title="Computes the VolumeDim-1 dimensional mesh on an interface from the volume mesh. Tags::InterfaceComput...">InterfaceMesh</a>&lt;VolumeDim&gt;&gt;</code> is retrievable as <code><a class="el" href="structdomain_1_1Tags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;Dirs, <a class="el" href="structdomain_1_1Tags_1_1Mesh.html" title="The computational grid of the Element in the DataBox.">Mesh</a>&lt;VolumeDim&gt;&gt;</code> from the DataBox.  <a href="structdomain_1_1Tags_1_1InterfaceMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryCoordinates.html">domain::Tags::BoundaryCoordinates&lt; VolumeDim, MovingMesh &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the coordinates in the frame <code><a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in.">Frame</a></code> on the faces defined by <code><a class="el" href="structdomain_1_1Tags_1_1Direction.html" title="Direction to an interface">Direction</a></code>. Intended to be prefixed by a <code><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html" title="Compute tag for representing items computed on a set of interfaces. Can be retrieved using Tags::Inte...">Tags::InterfaceCompute</a></code> to define the directions on which to compute the coordinates.  <a href="structdomain_1_1Tags_1_1BoundaryCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1LogicalCoordinates.html">domain::Tags::LogicalCoordinates&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical coordinates in the <a class="el" href="structdomain_1_1Tags_1_1Element.html" title="The Element associated with the DataBox.">Element</a>.  <a href="structdomain_1_1Tags_1_1LogicalCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MinimumGridSpacing.html">domain::Tags::MinimumGridSpacing&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum coordinate distance between grid points.  <a href="structdomain_1_1Tags_1_1MinimumGridSpacing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1OptionTags_1_1DomainCreator.html">domain::OptionTags::DomainCreator&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input file tag for the <a class="el" href="structdomain_1_1OptionTags_1_1DomainCreator.html" title="The input file tag for the DomainCreator to use.">DomainCreator</a> to use.  <a href="structdomain_1_1OptionTags_1_1DomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1SizeOfElement.html">domain::Tags::SizeOfElement&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inertial-coordinate size of an element along each of its logical directions.  <a href="structdomain_1_1Tags_1_1SizeOfElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIndex.html" title="An integer multi-index.">Index</a> a block of the computational domain.  <a href="classdomain_1_1BlockId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockNeighbor.html">BlockNeighbor&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbor of a host <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in a particular direction.  <a href="classBlockNeighbor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirection.html">Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A particular Side along a particular coordinate Axis.  <a href="classDirection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectionHash.html">DirectionHash&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a perfect hash if the size of the hash table is <code>2 * Dim</code>. To take advantage of this, use the <code><a class="el" href="classFixedHashMap.html" title="A hash table with a compile-time specified maximum size and ability to efficiently handle perfect has...">FixedHashMap</a></code> class.  <a href="structDirectionHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirectionMap.html">DirectionMap&lt; Dim, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimized map with <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> keys.  <a href="classDirectionMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html">Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spectral element with knowledge of its neighbors.  <a href="classElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementId.html">ElementId&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> uniquely labels an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="classElementId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExcisionSphere.html">ExcisionSphere&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The excision sphere information of a computational domain. The excision sphere is assumed to be a coordinate sphere in the grid frame.  <a href="classExcisionSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeighbors.html">Neighbors&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbors of a host <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> in a particular direction.  <a href="classNeighbors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrientationMap.html">OrientationMap&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of the host.  <a href="classOrientationMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSegmentId.html">SegmentId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classSegmentId.html" title="A SegmentId labels a segment of the interval  and is used to identify the bounds of an Element in a B...">SegmentId</a> labels a segment of the interval \([-1,1]\) and is used to identify the bounds of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> in a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in each dimension.  <a href="classSegmentId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Domain.html">domain::Tags::Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>.  <a href="structdomain_1_1Tags_1_1Domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialExtents.html">domain::Tags::InitialExtents&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grid points per dimension for all elements in each block of the initial computational domain.  <a href="structdomain_1_1Tags_1_1InitialExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialRefinementLevels.html">domain::Tags::InitialRefinementLevels&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial refinement level per dimension for all elements in each block of the initial computational domain.  <a href="structdomain_1_1Tags_1_1InitialRefinementLevels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Element.html">domain::Tags::Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> associated with the DataBox.  <a href="structdomain_1_1Tags_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Mesh.html">domain::Tags::Mesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computational grid of the <a class="el" href="structdomain_1_1Tags_1_1Element.html" title="The Element associated with the DataBox.">Element</a> in the DataBox.  <a href="structdomain_1_1Tags_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1ElementMap.html">domain::Tags::ElementMap&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate map from the ElementLogical frame to the TargetFrame.  <a href="structdomain_1_1Tags_1_1ElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Coordinates.html">domain::Tags::Coordinates&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in a given frame.  <a href="structdomain_1_1Tags_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MappedCoordinates.html">domain::Tags::MappedCoordinates&lt; MapTag, SourceCoordsTag, CoordinatesTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in the target frame of <code>MapTag</code>. The <code>SourceCoordsTag</code>'s frame must be the source frame of <code>MapTag</code>  <a href="structdomain_1_1Tags_1_1MappedCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobian.html">domain::Tags::InverseJacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1InverseJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobianCompute.html">domain::Tags::InverseJacobianCompute&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> of the map held by <code>MapTag</code> at the coordinates held by <code>SourceCoordsTag</code>. The coordinates must be in the source frame of the map.  <a href="structdomain_1_1Tags_1_1InverseJacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Jacobian.html">domain::Tags::Jacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1Jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1JacobianCompute.html">domain::Tags::JacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> of the map from the <code><a class="el" href="structdomain_1_1Tags_1_1InverseJacobian.html" title="The inverse Jacobian from the source frame to the target frame.">InverseJacobian</a>&lt;Dim, SourceFrame, TargetFrame&gt;</code> tag.  <a href="structdomain_1_1Tags_1_1JacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobian.html">domain::Tags::DetInvJacobian&lt; SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The determinant of the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1DetInvJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobianCompute.html">domain::Tags::DetInvJacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a>.  <a href="structdomain_1_1Tags_1_1DetInvJacobianCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1VariablesBoundaryData.html">domain::Tags::VariablesBoundaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base tag for boundary data needed for updating the variables.  <a href="structdomain_1_1Tags_1_1VariablesBoundaryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InternalDirections.html">domain::Tags::InternalDirections&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions to neighboring Elements.  <a href="structdomain_1_1Tags_1_1InternalDirections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsInterior.html">domain::Tags::BoundaryDirectionsInterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. Used for representing data on the interior side of the external boundary faces.  <a href="structdomain_1_1Tags_1_1BoundaryDirectionsInterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsExterior.html">domain::Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. To be used to represent data which exists on the exterior side of the external boundary faces.  <a href="structdomain_1_1Tags_1_1BoundaryDirectionsExterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Interface.html">domain::Tags::Interface&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts on tags on an interface, or base tag to a compute item which slices a tag from the volume to an interface.  <a href="structdomain_1_1Tags_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Direction.html">domain::Tags::Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> to an interface  <a href="structdomain_1_1Tags_1_1Direction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga39eb7361b3bcfe317a1576be5141b10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">More...</a><br /></td></tr>
<tr class="separator:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45607952ebcf523987906a5c27ccef59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga45607952ebcf523987906a5c27ccef59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">More...</a><br /></td></tr>
<tr class="separator:ga45607952ebcf523987906a5c27ccef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8773fe02f44b68af479cb53dd4383978"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(MAPS_TUPLE,  SOURCE_FRAME,  TARGET_FRAMES_TUPLE,  TYPES_TUPLE)</td></tr>
<tr class="memdesc:ga8773fe02f44b68af479cb53dd4383978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">More...</a><br /></td></tr>
<tr class="separator:ga8773fe02f44b68af479cb53dd4383978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a> { <br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360">amr::Flag::Undefined</a>
, <a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f">amr::Flag::Join</a>
, <a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147">amr::Flag::DecreaseResolution</a>
, <a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7">amr::Flag::DoNothing</a>
, <br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273">amr::Flag::IncreaseResolution</a>
, <a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2">amr::Flag::Split</a>
<br />
 }</td></tr>
<tr class="memdesc:ga6874579f1400ff7d0d77cbfa978289e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags that represent decisions about mesh refinement.  <a href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">More...</a><br /></td></tr>
<tr class="separator:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> { <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>
, <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45">ShellWedges::FourOnEquator</a>
, <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb">ShellWedges::OneAlongMinusX</a>
 }</td></tr>
<tr class="memdesc:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of wedges to include in the Shell domain.  <a href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">More...</a><br /></td></tr>
<tr class="separator:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> { <b>Lower</b>
, <b>Upper</b>
 }</td></tr>
<tr class="memdesc:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A label for the side of a manifold.  <a href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">More...</a><br /></td></tr>
<tr class="separator:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad60642b14ae0154b576b52342b7f1f7b"><td class="memTemplParams" colspan="2"><a id="gad60642b14ae0154b576b52342b7f1f7b" name="gad60642b14ae0154b576b52342b7f1f7b"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gad60642b14ae0154b576b52342b7f1f7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amr::desired_refinement_levels</b> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;flags)</td></tr>
<tr class="memdesc:gad60642b14ae0154b576b52342b7f1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>id</code> given the desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>flags</code> <br /></td></tr>
<tr class="separator:gad60642b14ae0154b576b52342b7f1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f075df01745cedd13c54ab534ced28f"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga2f075df01745cedd13c54ab534ced28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2f075df01745cedd13c54ab534ced28f">amr::desired_refinement_levels_of_neighbor</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_flags, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:ga2f075df01745cedd13c54ab534ced28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of a neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>neighbor_flags</code> taking into account the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> <code>orientation</code> of the neighbor.  <a href="group__ComputationalDomainGroup.html#ga2f075df01745cedd13c54ab534ced28f">More...</a><br /></td></tr>
<tr class="separator:ga2f075df01745cedd13c54ab534ced28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e722d38d4201c4a02cf11ad68d1ce74"><td class="memTemplParams" colspan="2"><a id="ga6e722d38d4201c4a02cf11ad68d1ce74" name="ga6e722d38d4201c4a02cf11ad68d1ce74"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga6e722d38d4201c4a02cf11ad68d1ce74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amr::has_potential_sibling</b> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;element_id, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga6e722d38d4201c4a02cf11ad68d1ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <code>element_id</code> can have a sibling in the given <code>direction</code> <br /></td></tr>
<tr class="separator:ga6e722d38d4201c4a02cf11ad68d1ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb313d11aadc2f2d56ec953bc7e37ad1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaeb313d11aadc2f2d56ec953bc7e37ad1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaeb313d11aadc2f2d56ec953bc7e37ad1">amr::update_amr_decision</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; * &gt; my_current_amr_flags, const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;element, const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_amr_flags)</td></tr>
<tr class="memdesc:gaeb313d11aadc2f2d56ec953bc7e37ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code>.  <a href="group__ComputationalDomainGroup.html#gaeb313d11aadc2f2d56ec953bc7e37ad1">More...</a><br /></td></tr>
<tr class="separator:gaeb313d11aadc2f2d56ec953bc7e37ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad820f28f973850990200bcb2d858fe1d"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:gad820f28f973850990200bcb2d858fe1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">block_logical_coordinates</a> (const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;domain, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;x, double time=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::signaling_NaN(), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time=<a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt;{}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, <a class="el" href="structFrame_1_1BlockLogical.html">::Frame::BlockLogical</a> &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gad820f28f973850990200bcb2d858fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in a particular frame.  <a href="group__ComputationalDomainGroup.html#gad820f28f973850990200bcb2d858fe1d">More...</a><br /></td></tr>
<tr class="separator:gad820f28f973850990200bcb2d858fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memTemplParams" colspan="2"><a id="ga96dc1aa7d7d767871d0eecf941f9b5a8" name="ga96dc1aa7d7d767871d0eecf941f9b5a8"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_coordinate_map</b> (Maps &amp;&amp;... maps) -&gt; <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;</td></tr>
<tr class="memdesc:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga96dc1aa7d7d767871d0eecf941f9b5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1668b4acdae04db8e32fe562f68abccb"><td class="memTemplParams" colspan="2"><a id="ga1668b4acdae04db8e32fe562f68abccb" name="ga1668b4acdae04db8e32fe562f68abccb"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga1668b4acdae04db8e32fe562f68abccb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_coordinate_map_base</b> (Maps &amp;&amp;... maps) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;::dim &gt; &gt;</td></tr>
<tr class="memdesc:ga1668b4acdae04db8e32fe562f68abccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;</code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga1668b4acdae04db8e32fe562f68abccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ab51e0621530cf6697181900c0f289"><td class="memTemplParams" colspan="2"><a id="gaa0ab51e0621530cf6697181900c0f289" name="gaa0ab51e0621530cf6697181900c0f289"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:gaa0ab51e0621530cf6697181900c0f289"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_vector_coordinate_map_base</b> (Arg0 &amp;&amp;arg_0, Args &amp;&amp;... remaining_args) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Arg0 &gt;::dim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaa0ab51e0621530cf6697181900c0f289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each argument passed in. <br /></td></tr>
<tr class="separator:gaa0ab51e0621530cf6697181900c0f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274e0101fff8b99a67419c3f496c9be3"><td class="memTemplParams" colspan="2"><a id="ga274e0101fff8b99a67419c3f496c9be3" name="ga274e0101fff8b99a67419c3f496c9be3"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t Dim, typename Map , typename... Maps&gt; </td></tr>
<tr class="memitem:ga274e0101fff8b99a67419c3f496c9be3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::make_vector_coordinate_map_base</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Map &gt; maps, const Maps &amp;... remaining_maps) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, Dim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga274e0101fff8b99a67419c3f496c9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each element of the vector of maps composed with the rest of the arguments passed in. <br /></td></tr>
<tr class="separator:ga274e0101fff8b99a67419c3f496c9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cd3961d1743137316f45a21e44e633"><td class="memTemplParams" colspan="2"><a id="gaa8cd3961d1743137316f45a21e44e633" name="gaa8cd3961d1743137316f45a21e44e633"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:gaa8cd3961d1743137316f45a21e44e633"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps..., NewMap &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::push_back</b> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map)</td></tr>
<tr class="memdesc:gaa8cd3961d1743137316f45a21e44e633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by appending the new map to the end of the old maps. <br /></td></tr>
<tr class="separator:gaa8cd3961d1743137316f45a21e44e633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81519ee0b09d6e2080198045a195794"><td class="memTemplParams" colspan="2"><a id="gac81519ee0b09d6e2080198045a195794" name="gac81519ee0b09d6e2080198045a195794"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:gac81519ee0b09d6e2080198045a195794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, NewMap, Maps... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>domain::push_front</b> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map)</td></tr>
<tr class="memdesc:gac81519ee0b09d6e2080198045a195794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by prepending the new map to the beginning of the old maps. <br /></td></tr>
<tr class="separator:gac81519ee0b09d6e2080198045a195794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027b0f10547532972db32bb8429a6373"><td class="memTemplParams" colspan="2"><a id="ga027b0f10547532972db32bb8429a6373" name="ga027b0f10547532972db32bb8429a6373"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga027b0f10547532972db32bb8429a6373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_internal_boundaries</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt; &amp;corners_of_all_blocks)</td></tr>
<tr class="memdesc:ga027b0f10547532972db32bb8429a6373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the BlockNeighbors using the corner numbering scheme provided by the user to deduce the correct neighbors and orientations. Does not set up periodic boundary conditions. <br /></td></tr>
<tr class="separator:ga027b0f10547532972db32bb8429a6373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99ad646c285e1457d42733ff283fba1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gab99ad646c285e1457d42733ff283fba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab99ad646c285e1457d42733ff283fba1">set_internal_boundaries</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &gt; &gt; &amp;maps)</td></tr>
<tr class="memdesc:gab99ad646c285e1457d42733ff283fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the BlockNeighbors using the corner numbering scheme implied by the maps provided by the user to deduce the correct neighbors and orientations.  <a href="group__ComputationalDomainGroup.html#gab99ad646c285e1457d42733ff283fba1">More...</a><br /></td></tr>
<tr class="separator:gab99ad646c285e1457d42733ff283fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd9512dd6916bf553bb13978951e44d"><td class="memTemplParams" colspan="2"><a id="ga3fd9512dd6916bf553bb13978951e44d" name="ga3fd9512dd6916bf553bb13978951e44d"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3fd9512dd6916bf553bb13978951e44d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_identified_boundaries</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt; &amp;corners_of_all_blocks, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt; neighbors_of_all_blocks)</td></tr>
<tr class="memdesc:ga3fd9512dd6916bf553bb13978951e44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up additional BlockNeighbors corresponding to any identifications of faces provided by the user. Can be used for manually setting up periodic boundary conditions. <br /></td></tr>
<tr class="separator:ga3fd9512dd6916bf553bb13978951e44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memTemplParams" colspan="2"><a id="ga92c8b5d0f433d2aba92efd0747a20110" name="ga92c8b5d0f433d2aba92efd0747a20110"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>indices_for_rectilinear_domains</b> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt;</td></tr>
<tr class="memdesc:ga92c8b5d0f433d2aba92efd0747a20110"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multi-indices that identify the individual Blocks in the lattice. <br /></td></tr>
<tr class="separator:ga92c8b5d0f433d2aba92efd0747a20110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae13666f13523f52e00e508129999c1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0ae13666f13523f52e00e508129999c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga0ae13666f13523f52e00e508129999c1">corners_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt;</td></tr>
<tr class="memdesc:ga0ae13666f13523f52e00e508129999c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a rectilinear domain made of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga0ae13666f13523f52e00e508129999c1">More...</a><br /></td></tr>
<tr class="separator:ga0ae13666f13523f52e00e508129999c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a661b637836b40e51bed17a7bf8925"><td class="memTemplParams" colspan="2"><a id="gad4a661b637836b40e51bed17a7bf8925" name="gad4a661b637836b40e51bed17a7bf8925"></a>
template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:gad4a661b637836b40e51bed17a7bf8925"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sph_wedge_coordinate_maps</b> (double inner_radius, double outer_radius, double inner_sphericity, double outer_sphericity, bool use_equiangular_map, double x_coord_of_shell_center=0.0, bool use_half_wedges=false, double aspect_ratio=1.0, size_t index_polar_axis=2, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gad4a661b637836b40e51bed17a7bf8925"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the CoordinateMaps of the Wedge&lt;3&gt;s used in the Sphere, Shell, and binary compact object DomainCreators. This function can also be used to wrap the Sphere or Shell in a cube made of six Wedge&lt;3&gt;s. The argument <code>x_coord_of_shell_center</code> specifies a translation of the Shell in the x-direction in the TargetFrame. For example, the BBH <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a> uses this to set the position of each BH. When the argument <code>use_half_wedges</code> is set to <code>true</code>, the wedges in the +z,-z,+y,-y directions are cut in half along their xi-axes. The resulting ten CoordinateMaps are used for the outermost Blocks of the BBH <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>. The argument <code>aspect_ratio</code> sets the equatorial compression factor, used by the EquatorialCompression maps which get composed with the Wedges. This is done if <code>aspect_ratio</code> is set to something other than the default value of one. The <code>radial_partitioning</code> specifies the radial boundaries of sub-shells between <code>inner_radius</code> and <code>outer_radius</code>. Set the <code>radial_distribution</code> to select the radial distribution of grid points in the spherical shells. <br /></td></tr>
<tr class="separator:gad4a661b637836b40e51bed17a7bf8925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164dc71b95a6246b893202155aaabe61"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga164dc71b95a6246b893202155aaabe61"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga164dc71b95a6246b893202155aaabe61">frustum_coordinate_maps</a> (double length_inner_cube, double length_outer_cube, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;origin_preimage={{0.0, 0.0, 0.0}}, double projective_scale_factor=1.0, double sphericity=0.0) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga164dc71b95a6246b893202155aaabe61"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction.  <a href="group__ComputationalDomainGroup.html#ga164dc71b95a6246b893202155aaabe61">More...</a><br /></td></tr>
<tr class="separator:ga164dc71b95a6246b893202155aaabe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00df68c8b8f3362d716905aaae483088"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga00df68c8b8f3362d716905aaae483088">corners_for_radially_layered_domains</a> (size_t number_of_layers, bool include_central_block, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners={{1, 2, 3, 4, 5, 6, 7, 8}}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>)</td></tr>
<tr class="memdesc:ga00df68c8b8f3362d716905aaae483088"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with radial layers.  <a href="group__ComputationalDomainGroup.html#ga00df68c8b8f3362d716905aaae483088">More...</a><br /></td></tr>
<tr class="separator:ga00df68c8b8f3362d716905aaae483088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gabdc7ac14ee646a462ce8fc921ab40f92">corners_for_biradially_layered_domains</a> (size_t number_of_radial_layers, size_t number_of_biradial_layers, bool include_central_block_lhs, bool include_central_block_rhs, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners_lhs={ {1, 2, 3, 4, 5, 6, 7, 8}})</td></tr>
<tr class="memdesc:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with biradial layers.  <a href="group__ComputationalDomainGroup.html#gabdc7ac14ee646a462ce8fc921ab40f92">More...</a><br /></td></tr>
<tr class="separator:gabdc7ac14ee646a462ce8fc921ab40f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6f9cd607fe3deeb525b1dc14d0b876c6">cyl_wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the CoordinateMaps used in the Cylinder <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>.  <a href="group__ComputationalDomainGroup.html#ga6f9cd607fe3deeb525b1dc14d0b876c6">More...</a><br /></td></tr>
<tr class="separator:ga6f9cd607fe3deeb525b1dc14d0b876c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2104aed15616a0d35eb5224366b60853"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2104aed15616a0d35eb5224366b60853">cyl_wedge_coord_map_center_blocks</a> (double inner_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}, CylindricalDomainParityFlip parity_flip=CylindricalDomainParityFlip::none) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga2104aed15616a0d35eb5224366b60853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>cyl_wedge_coordinate_maps</code>, but only the center square blocks,.  <a href="group__ComputationalDomainGroup.html#ga2104aed15616a0d35eb5224366b60853">More...</a><br /></td></tr>
<tr class="separator:ga2104aed15616a0d35eb5224366b60853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7f632f810cd61504431c933f9470fd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1b7f632f810cd61504431c933f9470fd">cyl_wedge_coord_map_surrounding_blocks</a> (double inner_radius, double outer_radius, double lower_z_bound, double upper_z_bound, bool use_equiangular_map, double inner_circularity, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;partitioning_in_z={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;radial_distribution={domain::CoordinateMaps::Distribution::Linear}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;distribution_in_z={domain::CoordinateMaps::Distribution::Linear}, CylindricalDomainParityFlip parity_flip=CylindricalDomainParityFlip::none) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 2 &gt;, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga1b7f632f810cd61504431c933f9470fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as cyl_wedge_coordinate_maps, but only the surrounding wedge blocks.  <a href="group__ComputationalDomainGroup.html#ga1b7f632f810cd61504431c933f9470fd">More...</a><br /></td></tr>
<tr class="separator:ga1b7f632f810cd61504431c933f9470fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0d40a514ae8440623b32a4420f9452"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7b0d40a514ae8440623b32a4420f9452">corners_for_cylindrical_layered_domains</a> (size_t number_of_shells, size_t number_of_discs)</td></tr>
<tr class="memdesc:ga7b0d40a514ae8440623b32a4420f9452"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a cylindrical domain split into discs with radial shells.  <a href="group__ComputationalDomainGroup.html#ga7b0d40a514ae8440623b32a4420f9452">More...</a><br /></td></tr>
<tr class="separator:ga7b0d40a514ae8440623b32a4420f9452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga24a1fcea4aafb78195851e7bd25394f5">discrete_rotation</a> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;corners_of_aligned)</td></tr>
<tr class="memdesc:ga24a1fcea4aafb78195851e7bd25394f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the corner numbers of an n-cube.  <a href="group__ComputationalDomainGroup.html#ga24a1fcea4aafb78195851e7bd25394f5">More...</a><br /></td></tr>
<tr class="separator:ga24a1fcea4aafb78195851e7bd25394f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772eeed19a2f610810889ac961d06e67"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga772eeed19a2f610810889ac961d06e67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga772eeed19a2f610810889ac961d06e67">maps_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;orientations_of_all_blocks={}, bool use_equiangular_map=false) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, VolumeDim &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga772eeed19a2f610810889ac961d06e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMaps for a rectilinear domain of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga772eeed19a2f610810889ac961d06e67">More...</a><br /></td></tr>
<tr class="separator:ga772eeed19a2f610810889ac961d06e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f206282b97b53259a861693d38fd298"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga7f206282b97b53259a861693d38fd298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7f206282b97b53259a861693d38fd298">rectilinear_domain</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1BoundaryConditions_1_1BoundaryCondition.html">domain::BoundaryConditions::BoundaryCondition</a> &gt; &gt; &gt; boundary_conditions={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;orientations_of_all_blocks={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;dimension_is_periodic=<a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt; VolumeDim &gt;(false), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications={}, bool use_equiangular_map=false)</td></tr>
<tr class="memdesc:ga7f206282b97b53259a861693d38fd298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes.  <a href="group__ComputationalDomainGroup.html#ga7f206282b97b53259a861693d38fd298">More...</a><br /></td></tr>
<tr class="separator:ga7f206282b97b53259a861693d38fd298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8679bb8131f836ff5e2d4deb1f4eff07">element_logical_coordinates</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;element_ids, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a> &gt; &gt; &gt; &gt; &amp;block_coord_holders) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt; &gt;</td></tr>
<tr class="memdesc:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point.  <a href="group__ComputationalDomainGroup.html#ga8679bb8131f836ff5e2d4deb1f4eff07">More...</a><br /></td></tr>
<tr class="separator:ga8679bb8131f836ff5e2d4deb1f4eff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memTemplParams" colspan="2">template&lt;typename CacheTag , typename Metavariables , typename ArrayIndex , typename Component , size_t N = 0&gt; </td></tr>
<tr class="memitem:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7de6fa2c6d431c00ca9fe7d309c10cd2">domain::functions_of_time_are_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const ArrayIndex &amp;array_index, const Component *, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, N &gt; &amp;functions_to_check=<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, 0 &gt;{})</td></tr>
<tr class="memdesc:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that functions of time are up-to-date.  <a href="group__ComputationalDomainGroup.html#ga7de6fa2c6d431c00ca9fe7d309c10cd2">More...</a><br /></td></tr>
<tr class="separator:ga7de6fa2c6d431c00ca9fe7d309c10cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3255acdd06d1f41f624e4519a9006082"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3255acdd06d1f41f624e4519a9006082"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;mesh, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga3255acdd06d1f41f624e4519a9006082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">More...</a><br /></td></tr>
<tr class="separator:ga3255acdd06d1f41f624e4519a9006082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0f4524b115d136aeafefab90cab6ad"><td class="memTemplParams" colspan="2"><a id="gabd0f4524b115d136aeafefab90cab6ad" name="gabd0f4524b115d136aeafefab90cab6ad"></a>
template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:gabd0f4524b115d136aeafefab90cab6ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minimum_grid_spacing</b> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;coords)</td></tr>
<tr class="memdesc:gabd0f4524b115d136aeafefab90cab6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum coordinate distance between grid points. <br /></td></tr>
<tr class="separator:gabd0f4524b115d136aeafefab90cab6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7277b2f5c68fd943f3e10da1b93485d8">index_to_slice_at</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const size_t offset=0)</td></tr>
<tr class="memdesc:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index in the perpendicular dimension of an element boundary.  <a href="group__ComputationalDomainGroup.html#ga7277b2f5c68fd943f3e10da1b93485d8">More...</a><br /></td></tr>
<tr class="separator:ga7277b2f5c68fd943f3e10da1b93485d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memTemplParams" colspan="2"><a id="ga0e375c0d81527dd6007a8dc0810d44b2" name="ga0e375c0d81527dd6007a8dc0810d44b2"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initial_element_ids</b> (size_t block_id, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; initial_ref_levs, size_t grid_index=0)</td></tr>
<tr class="memdesc:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. <br /></td></tr>
<tr class="separator:ga0e375c0d81527dd6007a8dc0810d44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797af5d3cab1d052a16c14d3faac8161"><td class="memTemplParams" colspan="2"><a id="ga797af5d3cab1d052a16c14d3faac8161" name="ga797af5d3cab1d052a16c14d3faac8161"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga797af5d3cab1d052a16c14d3faac8161"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initial_element_ids</b> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; &gt; &amp;initial_refinement_levels, size_t grid_index=0)</td></tr>
<tr class="memdesc:ga797af5d3cab1d052a16c14d3faac8161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the initial computational domain. <br /></td></tr>
<tr class="separator:ga797af5d3cab1d052a16c14d3faac8161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cb44daebc8f9e080718961530be89"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a> (const size_t dim)</td></tr>
<tr class="memdesc:gafa8cb44daebc8f9e080718961530be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions.  <a href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">More...</a><br /></td></tr>
<tr class="separator:gafa8cb44daebc8f9e080718961530be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">maximum_number_of_neighbors_per_direction</a> (const size_t dim)</td></tr>
<tr class="memdesc:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions.  <a href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">More...</a><br /></td></tr>
<tr class="separator:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memTemplParams" colspan="2"><a id="ga83a74526fa2d2d6d6b9d4081a76db3c1" name="ga83a74526fa2d2d6d6b9d4081a76db3c1"></a>
template&lt;size_t VolumeDim, typename T &gt; </td></tr>
<tr class="memitem:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_rotation</b> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;rotation, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, VolumeDim &gt; source_coords)</td></tr>
<tr class="memdesc:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a></code>s define an active rotation of the logical axes that bring the axes of a host block into alignment with the logical axes of the neighbor block. <code>discrete_rotation</code> applies this active rotation on the coordinates as opposed to the axes. For a two-dimensional example, consider a host block and a neighbor block, where the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> between them is \(\{-\eta,+\xi\}\). A quarter- turn counterclockwise of the host block's logical axes would bring them into alignment with those of the neighbor. That is, after this active rotation, the blocks would be Aligned. Now consider a point A with coordinates (+1.0,-0.5). An active quarter-turn rotation counter-clockwise about the origin, keeping the axes fixed, brings point A into the coordinates (+0.5,+1.0). This is how <code>discrete_rotation</code> interprets the <code><a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a></code> passed to it. <br /></td></tr>
<tr class="separator:ga83a74526fa2d2d6d6b9d4081a76db3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafc2f76a2d422ac605ac2c22de56a2bd3">discrete_rotation_jacobian</a> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code>  <a href="group__ComputationalDomainGroup.html#gafc2f76a2d422ac605ac2c22de56a2bd3">More...</a><br /></td></tr>
<tr class="separator:gafc2f76a2d422ac605ac2c22de56a2bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49106ff288c9b60897a13b72946ef347"><td class="memTemplParams" colspan="2"><a id="ga49106ff288c9b60897a13b72946ef347" name="ga49106ff288c9b60897a13b72946ef347"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga49106ff288c9b60897a13b72946ef347"><td class="memTemplItemLeft" align="right" valign="top">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_rotation_inverse_jacobian</b> (const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation)</td></tr>
<tr class="memdesc:ga49106ff288c9b60897a13b72946ef347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code> <br /></td></tr>
<tr class="separator:ga49106ff288c9b60897a13b72946ef347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649a7da35c207e46d234256976b33103"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga649a7da35c207e46d234256976b33103"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;inv_jacobian_on_interface, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga649a7da35c207e46d234256976b33103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">More...</a><br /></td></tr>
<tr class="separator:ga649a7da35c207e46d234256976b33103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9feb4e7cd655d238161671644c3cda1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gae9feb4e7cd655d238161671644c3cda1"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gae9feb4e7cd655d238161671644c3cda1">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;inv_jacobian_on_interface, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gae9feb4e7cd655d238161671644c3cda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gae9feb4e7cd655d238161671644c3cda1">More...</a><br /></td></tr>
<tr class="separator:gae9feb4e7cd655d238161671644c3cda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35fc33b7c504dd9af13636624d56378"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gad35fc33b7c504dd9af13636624d56378"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gad35fc33b7c504dd9af13636624d56378">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gad35fc33b7c504dd9af13636624d56378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gad35fc33b7c504dd9af13636624d56378">More...</a><br /></td></tr>
<tr class="separator:gad35fc33b7c504dd9af13636624d56378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dfe0dd3fbf25876726e544c1443993"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga96dfe0dd3fbf25876726e544c1443993"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga96dfe0dd3fbf25876726e544c1443993">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga96dfe0dd3fbf25876726e544c1443993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga96dfe0dd3fbf25876726e544c1443993">More...</a><br /></td></tr>
<tr class="separator:ga96dfe0dd3fbf25876726e544c1443993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146ed5451c212031cd1824d032e0c9fd"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga146ed5451c212031cd1824d032e0c9fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga146ed5451c212031cd1824d032e0c9fd">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga146ed5451c212031cd1824d032e0c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga146ed5451c212031cd1824d032e0c9fd">More...</a><br /></td></tr>
<tr class="separator:ga146ed5451c212031cd1824d032e0c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa27bf2e1f6c4c39085dc8d91d9969931">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#gaa27bf2e1f6c4c39085dc8d91d9969931">More...</a><br /></td></tr>
<tr class="separator:gaa27bf2e1f6c4c39085dc8d91d9969931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga43b8d40f75ed4eb339bc14c73038e697">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga43b8d40f75ed4eb339bc14c73038e697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga43b8d40f75ed4eb339bc14c73038e697">More...</a><br /></td></tr>
<tr class="separator:ga43b8d40f75ed4eb339bc14c73038e697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b573aba8992f8a67126994057a6ebc"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga12b573aba8992f8a67126994057a6ebc"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga12b573aba8992f8a67126994057a6ebc">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction)</td></tr>
<tr class="memdesc:ga12b573aba8992f8a67126994057a6ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga12b573aba8992f8a67126994057a6ebc">More...</a><br /></td></tr>
<tr class="separator:ga12b573aba8992f8a67126994057a6ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt; logical_coords, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">More...</a><br /></td></tr>
<tr class="separator:ga1b413be413e7562d25ad9c3c9c3cc7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244443757eca7cce2a735011474c7c20"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga244443757eca7cce2a735011474c7c20"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga244443757eca7cce2a735011474c7c20">logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga244443757eca7cce2a735011474c7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga244443757eca7cce2a735011474c7c20">More...</a><br /></td></tr>
<tr class="separator:ga244443757eca7cce2a735011474c7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4c280017c392c47a68ce156010b271"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga6b4c280017c392c47a68ce156010b271"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6b4c280017c392c47a68ce156010b271">size_of_element</a> (const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;logical_to_inertial_map)</td></tr>
<tr class="memdesc:ga6b4c280017c392c47a68ce156010b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="group__ComputationalDomainGroup.html#ga6b4c280017c392c47a68ce156010b271">More...</a><br /></td></tr>
<tr class="separator:ga6b4c280017c392c47a68ce156010b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3a4bc0136871c65fe8a305576ea2b171">size_of_element</a> (const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;logical_to_grid_map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;grid_to_inertial_map, double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:ga3a4bc0136871c65fe8a305576ea2b171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="group__ComputationalDomainGroup.html#ga3a4bc0136871c65fe8a305576ea2b171">More...</a><br /></td></tr>
<tr class="separator:ga3a4bc0136871c65fe8a305576ea2b171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memTemplParams" colspan="2"><a id="gad98ba46f9ff56f10f53f950f6fa0401d" name="gad98ba46f9ff56f10f53f950f6fa0401d"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orient_variables</b> (const Variables&lt; TagsList &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:gad98ba46f9ff56f10f53f950f6fa0401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memTemplParams" colspan="2"><a id="gaca3eaabeb785ff54a70ccf02a44b931f" name="gaca3eaabeb785ff54a70ccf02a44b931f"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orient_variables_on_slice</b> (const Variables&lt; TagsList &gt; &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, const size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:gaca3eaabeb785ff54a70ccf02a44b931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa7bda3cdc5430928c0ad8b1f2d6909d9">orient_variables</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#gaa7bda3cdc5430928c0ad8b1f2d6909d9">More...</a><br /></td></tr>
<tr class="separator:gaa7bda3cdc5430928c0ad8b1f2d6909d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1ea39f708807d4a31ea2429b4357f38b">orient_variables_on_slice</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, size_t sliced_dim, const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;orientation_of_neighbor)</td></tr>
<tr class="memdesc:ga1ea39f708807d4a31ea2429b4357f38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> representing one or more tensor components.  <a href="group__ComputationalDomainGroup.html#ga1ea39f708807d4a31ea2429b4357f38b">More...</a><br /></td></tr>
<tr class="separator:ga1ea39f708807d4a31ea2429b4357f38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The building blocks used to describe the computational domain. </p>
<h3><a class="anchor" id="autotoc_md153"></a>
Description</h3>
<p >The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>s. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is subdivided into one or more <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>s that may be changed dynamically if AMR is enabled.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
Description</h3>
<p >The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>s. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is subdivided into one or more <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>s that may be changed dynamically if AMR is enabled. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga45607952ebcf523987906a5c27ccef59" name="ga45607952ebcf523987906a5c27ccef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45607952ebcf523987906a5c27ccef59">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                        (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                        (<span class="keywordtype">double</span>, <a class="code hl_class" href="classDataVector.html">DataVector</a>))</div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:46</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1Affine_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a></div><div class="ttdoc">Affine map from .</div><div class="ttdef"><b>Definition:</b> Affine.hpp:37</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf2Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a></div><div class="ttdoc">Product of two codimension=0 CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:35</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf3Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a></div><div class="ttdoc">Product of three one-dimensional CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:89</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga45607952ebcf523987906a5c27ccef59"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:149</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad7b776398a66e9a6bd561c8decf08b47"><div class="ttname"><a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a></div><div class="ttdeci">#define GENERATE_INSTANTIATIONS(INSTANTIATION_MACRO,...)</div><div class="ttdoc">Macro useful for generating many explicit instantiations of function or class templates.</div><div class="ttdef"><b>Definition:</b> GenerateInstantiations.hpp:160</div></div>
<div class="ttc" id="astructFrame_1_1BlockLogical_html"><div class="ttname"><a href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:42</div></div>
<div class="ttc" id="astructFrame_1_1Grid_html"><div class="ttname"><a href="structFrame_1_1Grid.html">Frame::Grid</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:44</div></div>
<div class="ttc" id="astructFrame_1_1Inertial_html"><div class="ttname"><a href="structFrame_1_1Inertial.html">Frame::Inertial</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:45</div></div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>. The last tuple is the data types for which to instantiate the functions, usually <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga8773fe02f44b68af479cb53dd4383978" name="ga8773fe02f44b68af479cb53dd4383978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8773fe02f44b68af479cb53dd4383978">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MAPS_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SOURCE_FRAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TARGET_FRAMES_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPES_TUPLE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>, MAPS_TUPLE,    \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE)                \</div>
<div class="line">  GENERATE_INSTANTIATIONS(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>, MAPS_TUPLE, \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga39eb7361b3bcfe317a1576be5141b10f"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:78</div></div>
</div><!-- fragment -->
<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                           (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                           (<span class="keywordtype">double</span>, <a class="code hl_class" href="classDataVector.html">DataVector</a>))</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga8773fe02f44b68af479cb53dd4383978"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_FUNCTIONS(MAPS_TUPLE, SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:267</div></div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code></li>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga39eb7361b3bcfe317a1576be5141b10f" name="ga39eb7361b3bcfe317a1576be5141b10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39eb7361b3bcfe317a1576be5141b10f">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p >Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code hl_class" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code hl_define" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code hl_struct" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>),</div>
<div class="line">                        (<a class="code hl_struct" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code hl_struct" href="structFrame_1_1Inertial.html">Frame::Inertial</a>))</div>
</div><!-- fragment --><p >The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p >Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga6874579f1400ff7d0d77cbfa978289e2" name="ga6874579f1400ff7d0d77cbfa978289e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6874579f1400ff7d0d77cbfa978289e2">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags that represent decisions about mesh refinement. </p>
<p >In order to support anisotropic mesh refinement, a flag is specified for each dimension. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360" name="gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360"></a>Undefined&#160;</td><td class="fielddoc"><p >used to initialize flags before a decision is made </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f" name="gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f"></a>Join&#160;</td><td class="fielddoc"><p >join the sibling of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147" name="gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147"></a>DecreaseResolution&#160;</td><td class="fielddoc"><p >decrease number of points in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7" name="gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7"></a>DoNothing&#160;</td><td class="fielddoc"><p >stay the same </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273" name="gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273"></a>IncreaseResolution&#160;</td><td class="fielddoc"><p >increase number of points in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2" name="gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2"></a>Split&#160;</td><td class="fielddoc"><p >split the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> into two smaller elements </p>
</td></tr>
</table>

</div>
</div>
<a id="gac672a529d9aaa6a948b8b7eb6ec9b528" name="gac672a529d9aaa6a948b8b7eb6ec9b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac672a529d9aaa6a948b8b7eb6ec9b528">&#9670;&nbsp;</a></span>ShellWedges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of wedges to include in the Shell domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p >Use the entire shell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45"></a>FourOnEquator&#160;</td><td class="fielddoc"><p >Use only the four equatorial wedges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb" name="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb"></a>OneAlongMinusX&#160;</td><td class="fielddoc"><p >Use only the single wedge along -x. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8c0137d7160ad71b6ed265c53c99ed00" name="ga8c0137d7160ad71b6ed265c53c99ed00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0137d7160ad71b6ed265c53c99ed00">&#9670;&nbsp;</a></span>Side</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A label for the side of a manifold. </p>
<p >Lower and Upper are with respect to the logical coordinate whose axis is normal to the side, i.e. beyond the Upper (Lower) side, the logical coordinate is increasing (decreasing). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad820f28f973850990200bcb2d858fe1d" name="gad820f28f973850990200bcb2d858fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad820f28f973850990200bcb2d858fe1d">&#9670;&nbsp;</a></span>block_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto block_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;&#160;double&#160;&gt;::signaling_NaN()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;&#160;<a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a>&#160;&gt;&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, <a class="el" href="structFrame_1_1BlockLogical.html">::Frame::BlockLogical</a> &gt; &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in a particular frame. </p>
<h3>Details</h3>
<p >Returns a std::vector&lt;std::optional&lt;IdPair&lt;BlockId,coords&gt;&gt;&gt;, where the vector runs over the points and is indexed in the same order as the input coordinates <code>x</code>. For each point, the <code><a class="el" href="structIdPair.html" title="A data structure that contains an ID and data associated with that ID.">IdPair</a></code> holds the block logical coords of that point and the <code>BlockId</code> of the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> that contains that point. The <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a> is invalid if the point is not in any <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. If a point is on a shared boundary of two or more <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s, it is returned only once, and is considered to belong to the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> with the smaller <code>BlockId</code>. </p>

</div>
</div>
<a id="gabdc7ac14ee646a462ce8fc921ab40f92" name="gabdc7ac14ee646a462ce8fc921ab40f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc7ac14ee646a462ce8fc921ab40f92">&#9670;&nbsp;</a></span>corners_for_biradially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_biradially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_biradial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners_lhs</em> = <code>{&#160;{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a domain with biradial layers. </p>
<p >Generates the corners for a BBH-like <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping two interior volumes. The <code>number_of_radial_layers</code> gives the number of layers that fully envelop each interior volume with six Blocks each. The <code>number_of_biradial_layers</code> gives the number of layers that fully envelop both volumes at once, using ten Blocks per layer as opposed to six. The <code>central_block_corners_lhs</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga7b0d40a514ae8440623b32a4420f9452" name="ga7b0d40a514ae8440623b32a4420f9452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0d40a514ae8440623b32a4420f9452">&#9670;&nbsp;</a></span>corners_for_cylindrical_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_cylindrical_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_discs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a cylindrical domain split into discs with radial shells. </p>
<p >Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more stacked discs consisting of layers of Blocks enveloping an interior square prism. The <code>number_of_shells</code> specifies how many of these layers of Blocks to have in each disc.</p>
<p >The <code>number_of_discs</code> specifies how many discs make up the domain. The very basic cylinder with one shell and one layer serves as a base to generate the corners for subsequent shells first and discs second. </p>

</div>
</div>
<a id="ga00df68c8b8f3362d716905aaae483088" name="ga00df68c8b8f3362d716905aaae483088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00df68c8b8f3362d716905aaae483088">&#9670;&nbsp;</a></span>corners_for_radially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt; corners_for_radially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners</em> = <code>{{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a domain with radial layers. </p>
<p >Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping an interior volume, e.g. Shell or Sphere. The <code>number_of_layers</code> specifies how many of these layers of Blocks to have in the final domain. <code>include_central_block</code> is set to <code>true</code> in Sphere, where the interior volume is filled with a central <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, and <code>false</code> in Shell, where the interior volume is left empty. The <code>central_block_corners</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga0ae13666f13523f52e00e508129999c1" name="ga0ae13666f13523f52e00e508129999c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae13666f13523f52e00e508129999c1">&#9670;&nbsp;</a></span>corners_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto corners_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corners for a rectilinear domain made of n-cubes. </p>
<p >The <code>domain_extents</code> argument holds the number of blocks to have in each dimension. The blocks all have aligned orientations by construction. The <code>block_indices_to_exclude</code> argument allows the user to selectively exclude blocks from the resulting domain. This allows for the creation of non-trivial shapes such as the net for a tesseract. </p>

</div>
</div>
<a id="ga2104aed15616a0d35eb5224366b60853" name="ga2104aed15616a0d35eb5224366b60853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2104aed15616a0d35eb5224366b60853">&#9670;&nbsp;</a></span>cyl_wedge_coord_map_center_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coord_map_center_blocks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CylindricalDomainParityFlip&#160;</td>
          <td class="paramname"><em>parity_flip</em> = <code>CylindricalDomainParityFlip::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a>, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>cyl_wedge_coordinate_maps</code>, but only the center square blocks,. </p>
<p >If <code>CylindricalDomainParityFlip::z_direction</code> is specified, then the returned maps describe a cylinder with <code>lower_z_bound</code> corresponding to logical coordinate <code>upper_zeta</code> and <code>upper_z_bound</code> corresponding to logical coordinate <code>lower_zeta</code>, and thus the resulting maps are left-handed. <code>CylindricalDomainParityFlip::z_direction</code> is therefore useful only when composing with another map that is also left-handed, so that the composed coordinate system is right-handed.</p>
<p >Returned as a vector of the coordinate maps so that they can be composed with other maps later. </p>

</div>
</div>
<a id="ga1b7f632f810cd61504431c933f9470fd" name="ga1b7f632f810cd61504431c933f9470fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7f632f810cd61504431c933f9470fd">&#9670;&nbsp;</a></span>cyl_wedge_coord_map_surrounding_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coord_map_surrounding_blocks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_circularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CylindricalDomainParityFlip&#160;</td>
          <td class="paramname"><em>parity_flip</em> = <code>CylindricalDomainParityFlip::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt; <a class="el" href="classdomain_1_1CoordinateMaps_1_1Wedge.html">domain::CoordinateMaps::Wedge</a>&lt; 2 &gt;, <a class="el" href="classdomain_1_1CoordinateMaps_1_1Interval.html">domain::CoordinateMaps::Interval</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as cyl_wedge_coordinate_maps, but only the surrounding wedge blocks. </p>
<p >If <code>CylindricalDomainParityFlip::z_direction</code> is specified, then the returned maps describe a cylinder with <code>lower_z_bound</code> corresponding to logical coordinate <code>upper_zeta</code> and <code>upper_z_bound</code> corresponding to logical coordinate <code>lower_zeta</code>, and thus the resulting maps are left-handed. <code>CylindricalDomainParityFlip::z_direction</code> is therefore useful only when composing with another map that is also left-handed, so that the composed coordinate system is right-handed.</p>
<p >Returned as a vector of the coordinate maps so that they can be composed with other maps later. </p>

</div>
</div>
<a id="ga6f9cd607fe3deeb525b1dc14d0b876c6" name="ga6f9cd607fe3deeb525b1dc14d0b876c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9cd607fe3deeb525b1dc14d0b876c6">&#9670;&nbsp;</a></span>cyl_wedge_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_z_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioning_in_z</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_distribution</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacedomain_1_1CoordinateMaps.html#af1d0db78c5b853bb6b4870b87cd91053">domain::CoordinateMaps::Distribution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distribution_in_z</em> = <code>{domain::CoordinateMaps::Distribution::Linear}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the CoordinateMaps used in the Cylinder <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>. </p>
<p >The <code>radial_partitioning</code> specifies the radial boundaries of sub-shells between <code>inner_radius</code> and <code>outer_radius</code>, while <code>partitioning_in_z</code> specifies the z-boundaries, splitting the cylinder into stacked 3-dimensional disks. The circularity of the shell wedges changes from 0 to 1 within the innermost sub-shell.</p>
<p >Set the <code>radial_distribution</code> to select the radial distribution of grid points in the cylindrical shells. The innermost shell must have <code>domain::CoordinateMaps::Distribution::Linear</code> because it changes the circularity. The distribution along the z-axis for each circular disc is specified through <code>distribution_in_z</code>. </p>

</div>
</div>
<a id="ga2f075df01745cedd13c54ab534ced28f" name="ga2f075df01745cedd13c54ab534ced28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f075df01745cedd13c54ab534ced28f">&#9670;&nbsp;</a></span>desired_refinement_levels_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; amr::desired_refinement_levels_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the desired refinement level of a neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>neighbor_flags</code> taking into account the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> <code>orientation</code> of the neighbor. </p>
<h3>Details</h3>
<p >The <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> <code>orientation</code> is that from the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> that has a neighbor with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> </p>

</div>
</div>
<a id="ga24a1fcea4aafb78195851e7bd25394f5" name="ga24a1fcea4aafb78195851e7bd25394f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a1fcea4aafb78195851e7bd25394f5">&#9670;&nbsp;</a></span>discrete_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; discrete_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_aligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the corner numbers of an n-cube. </p>
<p >Returns the correct ordering of global corner numbers for a rotated block in an otherwise aligned edifice of blocks, given the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> a block aligned with the edifice has relative to this one, and given the corner numbering the rotated block would have if it were aligned. This is useful in creating domains for testing purposes, e.g. RotatedIntervals, RotatedRectangles, and RotatedBricks. </p>

</div>
</div>
<a id="gafc2f76a2d422ac605ac2c22de56a2bd3" name="gafc2f76a2d422ac605ac2c22de56a2bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2f76a2d422ac605ac2c22de56a2bd3">&#9670;&nbsp;</a></span>discrete_rotation_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::Ij&lt; double, VolumeDim, <a class="el" href="structFrame_1_1NoFrame.html">Frame::NoFrame</a> &gt; discrete_rotation_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian of the transformation that is computed by <code><a class="el" href="group__ComputationalDomainGroup.html#ga83a74526fa2d2d6d6b9d4081a76db3c1" title="OrientationMaps define an active rotation of the logical axes that bring the axes of a host block int...">discrete_rotation()</a></code> </p>
<dl class="section note"><dt>Note</dt><dd>This always returns a <code>double</code> because the Jacobian is spatially constant. </dd></dl>

</div>
</div>
<a id="ga8679bb8131f836ff5e2d4deb1f4eff07" name="ga8679bb8131f836ff5e2d4deb1f4eff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8679bb8131f836ff5e2d4deb1f4eff07">&#9670;&nbsp;</a></span>element_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto element_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a> &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_coord_holders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point. </p>
<h3>Details</h3>
<p >Returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> from <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s to <code><a class="el" href="structElementLogicalCoordHolder.html" title="Holds element logical coordinates of an arbitrary set of points on a single Element....">ElementLogicalCoordHolder</a></code>s. It is expected that only a subset of the points will be found in the given <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s. If a point is on a shared boundary of two or more <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code>s, it will be returned only once, and will be considered to belong to the first <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a></code> in the list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s. </p>

</div>
</div>
<a id="ga164dc71b95a6246b893202155aaabe61" name="ga164dc71b95a6246b893202155aaabe61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164dc71b95a6246b893202155aaabe61">&#9670;&nbsp;</a></span>frustum_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto frustum_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_inner_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_outer_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin_preimage</em> = <code>{{0.0,&#160;0.0,&#160;0.0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projective_scale_factor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphericity</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, 3 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction. </p>
<dl class="section see"><dt>See also</dt><dd>Frustum for details. </dd></dl>

</div>
</div>
<a id="ga7de6fa2c6d431c00ca9fe7d309c10cd2" name="ga7de6fa2c6d431c00ca9fe7d309c10cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7de6fa2c6d431c00ca9fe7d309c10cd2">&#9670;&nbsp;</a></span>functions_of_time_are_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CacheTag , typename Metavariables , typename ArrayIndex , typename Component , size_t N = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool domain::functions_of_time_are_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayIndex &amp;&#160;</td>
          <td class="paramname"><em>array_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_to_check</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,&#160;0&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that functions of time are up-to-date. </p>
<p >Check that functions of time in <code>CacheTag</code> with names in <code>functions_to_check</code> are ready at time <code>time</code>. If no names are listed in <code>functions_to_check</code>, checks all functions in <code>CacheTag</code>. If any function is not ready, schedules a <code><a class="el" href="classParallel_1_1PerformAlgorithmCallback.html" title="Wraps a call to perform_algorithm.">Parallel::PerformAlgorithmCallback</a></code> with the GlobalCache. </p>

</div>
</div>
<a id="ga7277b2f5c68fd943f3e10da1b93485d8" name="ga7277b2f5c68fd943f3e10da1b93485d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7277b2f5c68fd943f3e10da1b93485d8">&#9670;&nbsp;</a></span>index_to_slice_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t index_to_slice_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index in the perpendicular dimension of an element boundary. </p>
<p >Optionally provide an <code>offset</code> to find an index offset from the element boundary. </p>

</div>
</div>
<a id="ga3255acdd06d1f41f624e4519a9006082" name="ga3255acdd06d1f41f624e4519a9006082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3255acdd06d1f41f624e4519a9006082">&#9670;&nbsp;</a></span>interface_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; interface_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical coordinates on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<p ><em>Returns:</em> element logical-frame vector holding coordinates</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;2&gt;</a> mesh_3d_zbdry{</div>
<div class="line">      {{5, 3}}, Spectral::Basis::Legendre, Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d_lb_zeta = map_3d(</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a>(mesh_3d_zbdry, <a class="code hl_class" href="classDirection.html">Direction&lt;3&gt;::lower_zeta</a>()));</div>
<div class="ttc" id="aclassDirection_html"><div class="ttname"><a href="classDirection.html">Direction</a></div><div class="ttdoc">A particular Side along a particular coordinate Axis.</div><div class="ttdef"><b>Definition:</b> Direction.hpp:23</div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">Holds the number of grid points, basis, and quadrature in each direction of the computational grid.</div><div class="ttdef"><b>Definition:</b> Mesh.hpp:49</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga3255acdd06d1f41f624e4519a9006082"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga3255acdd06d1f41f624e4519a9006082">interface_logical_coordinates</a></div><div class="ttdeci">tnsr::I&lt; DataVector, VolumeDim, Frame::ElementLogical &gt; interface_logical_coordinates(const Mesh&lt; VolumeDim - 1 &gt; &amp;mesh, const Direction&lt; VolumeDim &gt; &amp;direction)</div><div class="ttdoc">Compute the logical coordinates on a face of an Element.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga244443757eca7cce2a735011474c7c20" name="ga244443757eca7cce2a735011474c7c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga244443757eca7cce2a735011474c7c20">&#9670;&nbsp;</a></span>logical_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div>
<div class="line">                        Spectral::Basis::Legendre,</div>
<div class="line">                        Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      Affine3d{x_map, y_map, z_map});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code hl_function" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a>(mesh_3d));</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga1b413be413e7562d25ad9c3c9c3cc7f0"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a></div><div class="ttdeci">void logical_coordinates(gsl::not_null&lt; tnsr::I&lt; DataVector, VolumeDim, Frame::ElementLogical &gt; * &gt; logical_coords, const Mesh&lt; VolumeDim &gt; &amp;mesh)</div><div class="ttdoc">Compute the logical coordinates in an Element.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1b413be413e7562d25ad9c3c9c3cc7f0" name="ga1b413be413e7562d25ad9c3c9c3cc7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b413be413e7562d25ad9c3c9c3cc7f0">&#9670;&nbsp;</a></span>logical_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void logical_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div>
<div class="line">                        Spectral::Basis::Legendre,</div>
<div class="line">                        Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      Affine3d{x_map, y_map, z_map});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code hl_function" href="group__ComputationalDomainGroup.html#ga1b413be413e7562d25ad9c3c9c3cc7f0">logical_coordinates</a>(mesh_3d));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga772eeed19a2f610810889ac961d06e67" name="ga772eeed19a2f610810889ac961d06e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga772eeed19a2f610810889ac961d06e67">&#9670;&nbsp;</a></span>maps_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame , size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto maps_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, TargetFrame, VolumeDim &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CoordinateMaps for a rectilinear domain of n-cubes. </p>
<p >Allows for both Affine and Equiangular maps. </p>

</div>
</div>
<a id="gafa8cb44daebc8f9e080718961530be89" name="gafa8cb44daebc8f9e080718961530be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8cb44daebc8f9e080718961530be89">&#9670;&nbsp;</a></span>maximum_number_of_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga45ff23a83bb3bab32bd30a13bc9a41a0" name="ga45ff23a83bb3bab32bd30a13bc9a41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ff23a83bb3bab32bd30a13bc9a41a0">&#9670;&nbsp;</a></span>maximum_number_of_neighbors_per_direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors_per_direction </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="gaa7bda3cdc5430928c0ad8b1f2d6909d9" name="gaa7bda3cdc5430928c0ad8b1f2d6909d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7bda3cdc5430928c0ad8b1f2d6909d9">&#9670;&nbsp;</a></span>orient_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; orient_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="ga1ea39f708807d4a31ea2429b4357f38b" name="ga1ea39f708807d4a31ea2429b4357f38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea39f708807d4a31ea2429b4357f38b">&#9670;&nbsp;</a></span>orient_variables_on_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; orient_variables_on_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables_on_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sliced_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> representing one or more tensor components. </p>
<p >In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="ga7f206282b97b53259a861693d38fd298" name="ga7f206282b97b53259a861693d38fd298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f206282b97b53259a861693d38fd298">&#9670;&nbsp;</a></span>rectilinear_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim &gt; rectilinear_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1BoundaryConditions_1_1BoundaryCondition.html">domain::BoundaryConditions::BoundaryCondition</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>boundary_conditions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classOrientationMap.html">OrientationMap</a>&lt; VolumeDim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimension_is_periodic</em> = <code><a class="el" href="group__UtilitiesGroup.html#gaef51773ec780d16fddcda8e5094f2a21">make_array</a>&lt;&#160;VolumeDim&#160;&gt;(false)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>identifications</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes. </p>
<h3>Details</h3>
<p >Useful for constructing domains for testing non-trivially connected rectilinear domains made up of cubes. We refer to a domain of this type as an edifice. The <code>domain_extents</code> provides the size (in the number of blocks) of the initial aligned edifice to construct. The <code>block_indices_to_exclude</code> parameter is used in refining the shape of the edifice from a cube to sometime more non-trivial, such as an L-shape or the net of a tesseract. The <code>block_demarcations</code> and <code>use_equiangular_map</code> parameters determine the CoordinateMaps to be used. <code>orientations_of_all_blocks</code> contains the <a class="el" href="classOrientationMap.html" title="A mapping of the logical coordinate axes of a host to the logical coordinate axes of a neighbor of th...">OrientationMap</a> of the edifice relative to each block.</p>
<p >The <code>identifications</code> parameter is used when identifying the faces of blocks in an edifice. This is used to identify the 1D boundaries in the 2D net for a 3D cube to construct a domain with topology S2. Note: If the user wishes to rotate the blocks as well as manually identify their faces, the user must provide the <a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a> corresponding to the rotated corners. </p>

</div>
</div>
<a id="gab99ad646c285e1457d42733ff283fba1" name="gab99ad646c285e1457d42733ff283fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99ad646c285e1457d42733ff283fba1">&#9670;&nbsp;</a></span>set_internal_boundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_internal_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt; &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>neighbors_of_all_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1BlockLogical.html">Frame::BlockLogical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the BlockNeighbors using the corner numbering scheme implied by the maps provided by the user to deduce the correct neighbors and orientations. </p>
<dl class="section warning"><dt>Warning</dt><dd>Does not set up periodic boundary conditions. </dd></dl>

</div>
</div>
<a id="ga3a4bc0136871c65fe8a305576ea2b171" name="ga3a4bc0136871c65fe8a305576ea2b171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4bc0136871c65fe8a305576ea2b171">&#9670;&nbsp;</a></span>size_of_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p >For each logical direction, compute the distance (in inertial coordinates) between the element's lower and upper faces in that logical direction. The distance is measured between centers of the faces, with the centers defined in the logical coordinates. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p >Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="ga6b4c280017c392c47a68ce156010b271" name="ga6b4c280017c392c47a68ce156010b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b4c280017c392c47a68ce156010b271">&#9670;&nbsp;</a></span>size_of_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_inertial_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p >For each logical direction, compute the distance (in inertial coordinates) between the element's lower and upper faces in that logical direction. The distance is measured between centers of the faces, with the centers defined in the logical coordinates. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p >Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="ga649a7da35c207e46d234256976b33103" name="ga649a7da35c207e46d234256976b33103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga649a7da35c207e46d234256976b33103">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jacobian_on_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga649a7da35c207e46d234256976b33103"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a></div><div class="ttdeci">void unnormalized_face_normal(const gsl::not_null&lt; tnsr::i&lt; DataVector, VolumeDim, TargetFrame &gt; * &gt; result, const Mesh&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const InverseJacobian&lt; DataVector, VolumeDim, Frame::ElementLogical, TargetFrame &gt; &amp;inv_jacobian_on_interface, const Direction&lt; VolumeDim &gt; &amp;direction)</div><div class="ttdoc">Compute the outward grid normal on a face of an Element.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa27bf2e1f6c4c39085dc8d91d9969931" name="gaa27bf2e1f6c4c39085dc8d91d9969931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27bf2e1f6c4c39085dc8d91d9969931">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga12b573aba8992f8a67126994057a6ebc" name="ga12b573aba8992f8a67126994057a6ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12b573aba8992f8a67126994057a6ebc">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga96dfe0dd3fbf25876726e544c1443993" name="ga96dfe0dd3fbf25876726e544c1443993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96dfe0dd3fbf25876726e544c1443993">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gae9feb4e7cd655d238161671644c3cda1" name="gae9feb4e7cd655d238161671644c3cda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9feb4e7cd655d238161671644c3cda1">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InverseJacobian&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_jacobian_on_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga43b8d40f75ed4eb339bc14c73038e697" name="ga43b8d40f75ed4eb339bc14c73038e697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b8d40f75ed4eb339bc14c73038e697">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid_to_inertial_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga146ed5451c212031cd1824d032e0c9fd" name="ga146ed5451c212031cd1824d032e0c9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146ed5451c212031cd1824d032e0c9fd">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1ElementLogical.html">Frame::ElementLogical</a>, TargetFrame, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad35fc33b7c504dd9af13636624d56378" name="gad35fc33b7c504dd9af13636624d56378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad35fc33b7c504dd9af13636624d56378">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a>. </p>
<h3>Details</h3>
<p >Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis.">Direction</a> and mapping it to the grid frame with the given map, or the given inverse Jacobian.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::ElementLogical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code hl_function" href="group__ComputationalDomainGroup.html#ga649a7da35c207e46d234256976b33103">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code hl_class" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaeb313d11aadc2f2d56ec953bc7e37ad1" name="gaeb313d11aadc2f2d56ec953bc7e37ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb313d11aadc2f2d56ec953bc7e37ad1">&#9670;&nbsp;</a></span>update_amr_decision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool amr::update_amr_decision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>my_current_amr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_amr_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors.">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code>. </p>
<h3>Details</h3>
<p >This function is called by each element when it receives the AMR decisions of one of its neighbors. If any of its flags are updated, the element should send its new decisions to each of its neighbors. The following changes are made to the current flags of the element:</p><ul>
<li>If the neighbor wants to be two or more refinement levels higher than the element, the flag is updated to bring the element to within one level</li>
<li>If the element wants to join, and the neighbor is a potential sibling but wants to be at a different refinement level in any dimension, the flag is updated to not do h-refinement.</li>
</ul>
<p ><em>Returns:</em> true if any flag is changed</p>
<dl class="section note"><dt>Note</dt><dd>Modifies <code>my_current_amr_flags</code> which are the AMR decisions of <code>element</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
