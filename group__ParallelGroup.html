<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Parallelization</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.01.03</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ParallelGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Parallelization</div></div>
</div><!--header-->
<div class="contents">

<p>Functions, classes and documentation related to parallelization and Charm++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceParallel_1_1InboxInserters"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceParallel_1_1InboxInserters.html">Parallel::InboxInserters</a></td></tr>
<tr class="memdesc:namespaceParallel_1_1InboxInserters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structs that have <code>insert_into_inbox</code> methods for commonly used cases. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html">Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed object (Charm++ Chare) that executes a series of Actions and is capable of sending and receiving data. Acts as an interface to Charm++.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmArray.html">AlgorithmArray&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ array chare.  <a href="classAlgorithmArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Array.html">Parallel::Algorithms::Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular array component.  <a href="structParallel_1_1Algorithms_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmGroup.html">AlgorithmGroup&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ group chare.  <a href="classAlgorithmGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Group.html">Parallel::Algorithms::Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular group component.  <a href="structParallel_1_1Algorithms_1_1Group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmNodegroup.html">AlgorithmNodegroup&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ nodegroup chare.  <a href="classAlgorithmNodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Nodegroup.html">Parallel::Algorithms::Nodegroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular nodegroup component.  <a href="structParallel_1_1Algorithms_1_1Nodegroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmSingleton.html">AlgorithmSingleton&lt; ParallelComponent, SpectreArrayIndex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Spectre algorithm object that wraps a charm++ singleton chare.  <a href="classAlgorithmSingleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Algorithms_1_1Singleton.html">Parallel::Algorithms::Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores the charm++ types relevant for a particular singleton component.  <a href="structParallel_1_1Algorithms_1_1Singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">Parallel::ArrayIndex&lt; Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1MutableGlobalCache.html">Parallel::MutableGlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches mutable data once per Charm++ core.  <a href="classParallel_1_1MutableGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1GlobalCache.html">Parallel::GlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++ core.  <a href="classParallel_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1GlobalCache.html">Parallel::Tags::GlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1GlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1FromGlobalCache.html">Parallel::Tags::FromGlobalCache&lt; CacheTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag used to retrieve data from the <code><a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">Parallel::GlobalCache</a></code>. This is the recommended way for compute tags to retrieve data out of the global cache.  <a href="structParallel_1_1Tags_1_1FromGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Parallel::Main&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable. See <a href="group__ParallelGroup.html#details">the Parallelization documentation</a> for an overview of Metavariables, Phases, and parallel components.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1NodeLock.html">Parallel::NodeLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typesafe wrapper for a lock for synchronization of shared resources on a given node, with safe creation, destruction, and serialization.  <a href="classParallel_1_1NodeLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions&lt; PhaseType, Phase, ActionsList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all the actions to be executed in the specified phase.  <a href="structParallel_1_1PhaseActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__action__list__from__phase__dep__action__list.html">Parallel::get_action_list_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the action list from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__action__list__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__phase__type__from__phase__dep__action__list.html">Parallel::get_phase_type_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the phase type from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__phase__type__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__phase__from__phase__dep__action__list.html">Parallel::get_phase_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the phase as a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a></code> from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase.">PhaseActions</a></code>  <a href="structParallel_1_1get__phase__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt; T, InvokeCombine, InvokeFinal, InvokeFinalExtraArgsIndices &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data to be reduced, and invokables to be called whenever two reduction messages are combined and after the reduction has been completed.  <a href="structParallel_1_1ReductionDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html">Parallel::ReductionData&lt; ReductionDatum&lt; Ts, InvokeCombines, InvokeFinals, InvokeFinalExtraArgsIndices &gt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing a possibly heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1Metavariables.html">Parallel::Tags::Metavariables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="structParallel_1_1Tags_1_1Metavariables.html" title="Tag to retrieve the Metavariables from the DataBox.">Metavariables</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1Metavariables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">Parallel::is_array_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare.  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__chare__proxy.html">Parallel::is_chare_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a chare.  <a href="structParallel_1_1is__chare__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">Parallel::is_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">Parallel::is_node_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">Parallel::is_bound_array&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">Parallel::has_pup_member&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">Parallel::is_pupable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga54770b986b9c522da6d651e1be125a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga54770b986b9c522da6d651e1be125a03">WRAPPED_PUPable_decl_template</a>(className)&#160;&#160;&#160;  PUPable_decl_template(SINGLE_ARG(className))</td></tr>
<tr class="memdesc:ga54770b986b9c522da6d651e1be125a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived classes as serializable.  <a href="group__ParallelGroup.html#ga54770b986b9c522da6d651e1be125a03">More...</a><br /></td></tr>
<tr class="separator:ga54770b986b9c522da6d651e1be125a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9eecd27ecadb3501ddae591bf07db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gade9eecd27ecadb3501ddae591bf07db0">WRAPPED_PUPable_decl_base_template</a>(baseClassName,  className)</td></tr>
<tr class="memdesc:gade9eecd27ecadb3501ddae591bf07db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived template classes as serializable.  <a href="group__ParallelGroup.html#gade9eecd27ecadb3501ddae591bf07db0">More...</a><br /></td></tr>
<tr class="separator:gade9eecd27ecadb3501ddae591bf07db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplParams" colspan="2"><a id="gae918917e798cb6dd36a6cca9ede77616" name="gae918917e798cb6dd36a6cca9ede77616"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_inbox_tags</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_inbox_tags_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae918917e798cb6dd36a6cca9ede77616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique inbox tags. <br /></td></tr>
<tr class="separator:gae918917e798cb6dd36a6cca9ede77616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplParams" colspan="2"><a id="gab2c3e5b7084f5cb31c8c5cc7595349a6" name="gab2c3e5b7084f5cb31c8c5cc7595349a6"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_const_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>const_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplParams" colspan="2"><a id="ga54c47960b4397660c8ece4b63da46558" name="ga54c47960b4397660c8ece4b63da46558"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:ga54c47960b4397660c8ece4b63da46558"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_mutable_global_cache_tags_from_actions</b> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga54c47960b4397660c8ece4b63da46558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>mutable_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:ga54c47960b4397660c8ece4b63da46558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplParams" colspan="2"><a id="ga03e3053314568ebf144ba895c04ead0e" name="ga03e3053314568ebf144ba895c04ead0e"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_const_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_const_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga03e3053314568ebf144ba895c04ead0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:ga03e3053314568ebf144ba895c04ead0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplParams" colspan="2"><a id="gab10d351ad8ecf07b1ec23dbad2e70a3d" name="gab10d351ad8ecf07b1ec23dbad2e70a3d"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_mutable_global_cache_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_mutable_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_mutable_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the mutable items in the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. <br /></td></tr>
<tr class="separator:gab10d351ad8ecf07b1ec23dbad2e70a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplParams" colspan="2"><a id="gac5fb42f8eaf4da2707e32ed37ecf4e66" name="gac5fb42f8eaf4da2707e32ed37ecf4e66"></a>
template&lt;typename PhaseDepActionList &gt; </td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_initialization_actions_list</b> = tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the phase dependent action list, return the list of actions in the Initialization phase (or an empty list if the Initialization phase is absent from the phase dependent action list) <br /></td></tr>
<tr class="separator:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplParams" colspan="2"><a id="ga1e2e4c961e55eb461d66770393e4f45d" name="ga1e2e4c961e55eb461d66770393e4f45d"></a>
template&lt;typename InitializationActionsList , typename AllocationTagsList  = tmpl::list&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_initialization_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; AllocationTagsList, tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1e2e4c961e55eb461d66770393e4f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, and possibly a list of tags needed for allocation of an array component, returns a list of the unique initialization_tags for all the actions (and the allocate function). <br /></td></tr>
<tr class="separator:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplParams" colspan="2"><a id="ga5fc2e63ea42550ab888291b78b3a0bb4" name="ga5fc2e63ea42550ab888291b78b3a0bb4"></a>
template&lt;typename InitializationActionsList &gt; </td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_initialization_tags_to_keep</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_to_keep_from_action&lt; tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, returns a list of the unique initialization_tags_to_keep for all the actions. These are the tags that are not removed from the DataBox after initialization. <br /></td></tr>
<tr class="separator:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619cbb884a70fef0cc726ffe1b379201"><td class="memTemplParams" colspan="2"><a id="ga619cbb884a70fef0cc726ffe1b379201" name="ga619cbb884a70fef0cc726ffe1b379201"></a>
template&lt;typename InitializationTagsList , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga619cbb884a70fef0cc726ffe1b379201"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::get_option_tags</b> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationTagsList, tmpl::bind&lt; detail::get_option_tags_from_initialization_tag&lt; Metavariables &gt;::template f, tmpl::_1 &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga619cbb884a70fef0cc726ffe1b379201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization tags, returns a list of the unique option tags required to construct them. <br /></td></tr>
<tr class="separator:ga619cbb884a70fef0cc726ffe1b379201"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplParams" colspan="2"><a id="gaed29f7ca4a887fbbea9e55d94f7674cd" name="gaed29f7ca4a887fbbea9e55d94f7674cd"></a>
template&lt;typename Metavariables , typename... Tags, typename... OptionTags&gt; </td></tr>
<tr class="memitem:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Tags... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::create_from_options</b> (const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; OptionTags... &gt; &amp;options, tmpl::list&lt; Tags... &gt;)</td></tr>
<tr class="memdesc:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of tags and a tagged tuple containing items created from input options, return a tagged tuple of items constructed by calls to create_from_options for each tag in the list. <br /></td></tr>
<tr class="separator:gaed29f7ca4a887fbbea9e55d94f7674cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067c1f93d4806b2e8132de92da444ffa"><td class="memTemplParams" colspan="2"><a id="ga067c1f93d4806b2e8132de92da444ffa" name="ga067c1f93d4806b2e8132de92da444ffa"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:ga067c1f93d4806b2e8132de92da444ffa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::number_of_procs</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga067c1f93d4806b2e8132de92da444ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga067c1f93d4806b2e8132de92da444ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78851527af07171f81868d5b7ab93f35"><td class="memTemplParams" colspan="2"><a id="ga78851527af07171f81868d5b7ab93f35" name="ga78851527af07171f81868d5b7ab93f35"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:ga78851527af07171f81868d5b7ab93f35"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_proc</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga78851527af07171f81868d5b7ab93f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:ga78851527af07171f81868d5b7ab93f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ae705d3ce3511224ff7abf9dedef77"><td class="memTemplParams" colspan="2"><a id="ga52ae705d3ce3511224ff7abf9dedef77" name="ga52ae705d3ce3511224ff7abf9dedef77"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:ga52ae705d3ce3511224ff7abf9dedef77"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::number_of_nodes</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga52ae705d3ce3511224ff7abf9dedef77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:ga52ae705d3ce3511224ff7abf9dedef77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdc1076db5784d94ea24e91b1853a47"><td class="memTemplParams" colspan="2"><a id="gabfdc1076db5784d94ea24e91b1853a47" name="gabfdc1076db5784d94ea24e91b1853a47"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:gabfdc1076db5784d94ea24e91b1853a47"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_node</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gabfdc1076db5784d94ea24e91b1853a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:gabfdc1076db5784d94ea24e91b1853a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2067a781436314e4d177bd0f623415"><td class="memTemplParams" colspan="2"><a id="ga0d2067a781436314e4d177bd0f623415" name="ga0d2067a781436314e4d177bd0f623415"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:ga0d2067a781436314e4d177bd0f623415"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::procs_on_node</b> (const int node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga0d2067a781436314e4d177bd0f623415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:ga0d2067a781436314e4d177bd0f623415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce58a3a278dd1cc03443d8a89eaf02e"><td class="memTemplParams" colspan="2"><a id="ga8ce58a3a278dd1cc03443d8a89eaf02e" name="ga8ce58a3a278dd1cc03443d8a89eaf02e"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:ga8ce58a3a278dd1cc03443d8a89eaf02e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::my_local_rank</b> (const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:ga8ce58a3a278dd1cc03443d8a89eaf02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga8ce58a3a278dd1cc03443d8a89eaf02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd3c0e5c52b340f7ee0673c411a4a6d"><td class="memTemplParams" colspan="2"><a id="gacdd3c0e5c52b340f7ee0673c411a4a6d" name="gacdd3c0e5c52b340f7ee0673c411a4a6d"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:gacdd3c0e5c52b340f7ee0673c411a4a6d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::first_proc_on_node</b> (const int node_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gacdd3c0e5c52b340f7ee0673c411a4a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:gacdd3c0e5c52b340f7ee0673c411a4a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1410567441aa7e9709456c3192d251"><td class="memTemplParams" colspan="2"><a id="gade1410567441aa7e9709456c3192d251" name="gade1410567441aa7e9709456c3192d251"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:gade1410567441aa7e9709456c3192d251"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::node_of</b> (const int proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gade1410567441aa7e9709456c3192d251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:gade1410567441aa7e9709456c3192d251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6e0d1e986c0739cc9a37198ebc5d46"><td class="memTemplParams" colspan="2"><a id="gacb6e0d1e986c0739cc9a37198ebc5d46" name="gacb6e0d1e986c0739cc9a37198ebc5d46"></a>
template&lt;typename DistribObject &gt; </td></tr>
<tr class="memitem:gacb6e0d1e986c0739cc9a37198ebc5d46"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::local_rank_of</b> (const int proc_index, const DistribObject &amp;distributed_object)</td></tr>
<tr class="memdesc:gacb6e0d1e986c0739cc9a37198ebc5d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gacb6e0d1e986c0739cc9a37198ebc5d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </td></tr>
<tr class="memitem:gad1078fa99233851c6475fbfa99a2f51d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">Parallel::receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data, const bool enable_if_disabled=false)</td></tr>
<tr class="memdesc:gad1078fa99233851c6475fbfa99a2f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#gad1078fa99233851c6475fbfa99a2f51d">More...</a><br /></td></tr>
<tr class="separator:gad1078fa99233851c6475fbfa99a2f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplParams" colspan="2"><a id="gabed954105c6dfd7cc13d07dbcb0504b1" name="gabed954105c6dfd7cc13d07dbcb0504b1"></a>
template&lt;typename Action , typename Proxy , typename... Args&gt; </td></tr>
<tr class="memitem:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::local_synchronous_action</b> (Proxy &amp;&amp;proxy, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a local synchronous action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gabed954105c6dfd7cc13d07dbcb0504b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">Parallel::printf_error</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa8448205dbaf9741505bd30dfad2cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stderr with C printf usage.  <a href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">More...</a><br /></td></tr>
<tr class="separator:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplParams" colspan="2">template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </td></tr>
<tr class="memitem:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">Parallel::contribute_to_reduction</a> (ReductionData&lt; Ts... &gt; reduction_data, const SenderProxy &amp;sender_component, const TargetProxy &amp;target_component, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt; section=&amp;no_section())</td></tr>
<tr class="memdesc:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction.  <a href="group__ParallelGroup.html#ga893fa42fabb3cb7273cfdd7348e9a75d">More...</a><br /></td></tr>
<tr class="separator:ga893fa42fabb3cb7273cfdd7348e9a75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313d201814db8c6e1c64fce9384276a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga313d201814db8c6e1c64fce9384276a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga313d201814db8c6e1c64fce9384276a3">serialize</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ga313d201814db8c6e1c64fce9384276a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object using PUP.  <a href="group__ParallelGroup.html#ga313d201814db8c6e1c64fce9384276a3">More...</a><br /></td></tr>
<tr class="separator:ga313d201814db8c6e1c64fce9384276a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6fb3864413e851ea6dcd1ffa319f2f25">deserialize</a> (const void *const data)</td></tr>
<tr class="memdesc:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="group__ParallelGroup.html#ga6fb3864413e851ea6dcd1ffa319f2f25">More...</a><br /></td></tr>
<tr class="separator:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3479433cebc81e70d646c6c755b47e1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3479433cebc81e70d646c6c755b47e1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga3479433cebc81e70d646c6c755b47e1d">deserialize</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const void *const data)</td></tr>
<tr class="memdesc:ga3479433cebc81e70d646c6c755b47e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="group__ParallelGroup.html#ga3479433cebc81e70d646c6c755b47e1d">More...</a><br /></td></tr>
<tr class="separator:ga3479433cebc81e70d646c6c755b47e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">Parallel::get_parallel_component</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#gaeee02b1e4faf8051fe703e6b9adada0f">More...</a><br /></td></tr>
<tr class="separator:gaeee02b1e4faf8051fe703e6b9adada0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga8c24e9812c22ee923354a3906e50f296"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">Parallel::get_parallel_component</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const Parallel::proxy_from_parallel_component&lt; GlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt; &gt; &amp;</td></tr>
<tr class="memdesc:ga8c24e9812c22ee923354a3906e50f296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga8c24e9812c22ee923354a3906e50f296">More...</a><br /></td></tr>
<tr class="separator:ga8c24e9812c22ee923354a3906e50f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">Parallel::get</a> (const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache) -&gt; const GlobalCache_detail::type_for_get&lt; GlobalCacheTag, Metavariables &gt; &amp;</td></tr>
<tr class="memdesc:ga43c98b994ca4a6ef61235109c5b94e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__ParallelGroup.html#ga43c98b994ca4a6ef61235109c5b94e14">More...</a><br /></td></tr>
<tr class="separator:ga43c98b994ca4a6ef61235109c5b94e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </td></tr>
<tr class="memitem:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">Parallel::mutable_cache_item_is_ready</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, const Function &amp;function)</td></tr>
<tr class="memdesc:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>.  <a href="group__ParallelGroup.html#gaee973d82ab6a1dbac2b504e86d8de2e5">More...</a><br /></td></tr>
<tr class="separator:gaee973d82ab6a1dbac2b504e86d8de2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">Parallel::mutate</a> (<a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;cache, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8fb8fc6f30581c450abecc8258dead3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates non-const data in the cache, by calling <code>Function::apply()</code>  <a href="group__ParallelGroup.html#ga8fb8fc6f30581c450abecc8258dead3c">More...</a><br /></td></tr>
<tr class="separator:ga8fb8fc6f30581c450abecc8258dead3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6490a57edb52d447ca1b7fa83b2175"><td class="memTemplParams" colspan="2">template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </td></tr>
<tr class="memitem:ga9a6490a57edb52d447ca1b7fa83b2175"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga9a6490a57edb52d447ca1b7fa83b2175">Parallel::mutate</a> (CProxy_GlobalCache&lt; Metavariables &gt; &amp;cache_proxy, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga9a6490a57edb52d447ca1b7fa83b2175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates non-const data in the cache, by calling <code>Function::apply()</code>  <a href="group__ParallelGroup.html#ga9a6490a57edb52d447ca1b7fa83b2175">More...</a><br /></td></tr>
<tr class="separator:ga9a6490a57edb52d447ca1b7fa83b2175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplParams" colspan="2"><a id="ga1902e18e22b3092208b8dd9f0e5f11c0" name="ga1902e18e22b3092208b8dd9f0e5f11c0"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::simple_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga1902e18e22b3092208b8dd9f0e5f11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplParams" colspan="2"><a id="ga8e9708c581cfd958746b601be4a03eb5" name="ga8e9708c581cfd958746b601be4a03eb5"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga8e9708c581cfd958746b601be4a03eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::simple_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8e9708c581cfd958746b601be4a03eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:ga8e9708c581cfd958746b601be4a03eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplParams" colspan="2"><a id="ga49eb59320a0258c95d58b1447ff8702b" name="ga49eb59320a0258c95d58b1447ff8702b"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga49eb59320a0258c95d58b1447ff8702b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::threaded_action</b> (Proxy &amp;&amp;proxy)</td></tr>
<tr class="memdesc:ga49eb59320a0258c95d58b1447ff8702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga49eb59320a0258c95d58b1447ff8702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplParams" colspan="2"><a id="ga942169b97926623cb569158e724e62e0" name="ga942169b97926623cb569158e724e62e0"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga942169b97926623cb569158e724e62e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Parallel::threaded_action</b> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga942169b97926623cb569158e724e62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga942169b97926623cb569158e724e62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions, classes and documentation related to parallelization and Charm++. </p>
<p >See <a class="el" href="dev_guide_parallelization_foundations.html">Parallelization infrastructure</a> for details. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade9eecd27ecadb3501ddae591bf07db0" name="gade9eecd27ecadb3501ddae591bf07db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9eecd27ecadb3501ddae591bf07db0">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_base_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_base_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">baseClassName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  PUPable_decl_base_template(SINGLE_ARG(baseClassName), <span class="comment">/* NOLINT */</span> \</div>
<div class="line">                             SINGLE_ARG(className))</div>
</div><!-- fragment -->
<p>Mark derived template classes as serializable. </p>
<p >Any class that inherits from an abstract base class where the base class is a template class must contain this macro if it is to be serialized. </p>

</div>
</div>
<a id="ga54770b986b9c522da6d651e1be125a03" name="ga54770b986b9c522da6d651e1be125a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54770b986b9c522da6d651e1be125a03">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className</td><td>)</td>
          <td>&#160;&#160;&#160;  PUPable_decl_template(SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived classes as serializable. </p>
<p >Any class that inherits from an abstract base class where the base class is not a template class must contain this macro if it is to be serialized. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga893fa42fabb3cb7273cfdd7348e9a75d" name="ga893fa42fabb3cb7273cfdd7348e9a75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893fa42fabb3cb7273cfdd7348e9a75d">&#9670;&nbsp;</a></span>contribute_to_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts, class SectionType  = NoSection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_reduction </td>
          <td>(</td>
          <td class="paramtype">ReductionData&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>reduction_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SenderProxy &amp;&#160;</td>
          <td class="paramname"><em>sender_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetProxy &amp;&#160;</td>
          <td class="paramname"><em>target_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SectionType * &gt;&#160;</td>
          <td class="paramname"><em>section</em> = <code>&amp;no_section()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction. </p>
<dl class="section user"><dt>Section reductions</dt><dd>This function supports section reductions (see <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code>). Pass the <code><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Parallel::Section</a></code> as the <code>section</code> argument, or pass <code>Parallel::no_section()</code> to perform a reduction over the entire parallel component (default). Here's an example of a section reduction:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">auto</span>&amp; array_section = <a class="code hl_function" href="group__DataBoxGroup.html#gac94b70fab454bd5ae3b218f0ed182684">db::get_mutable_reference</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="structParallel_1_1Tags_1_1Section.html">Parallel::Tags::Section&lt;ParallelComponent, ArraySectionIdTag&gt;</a>&gt;(</div>
<div class="line">        make_not_null(&amp;box));</div>
<div class="line">    <span class="keywordflow">if</span> (array_section.has_value()) {</div>
<div class="line">      <span class="comment">// We&#39;ll just count the elements in each section</span></div>
<div class="line">      Parallel::ReductionData&lt;</div>
<div class="line">          <a class="code hl_struct" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt;bool, funcl::AssertEqual&lt;&gt;</a>&gt;,</div>
<div class="line">          <a class="code hl_struct" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt;size_t, funcl::Plus&lt;&gt;</a>&gt;&gt;</div>
<div class="line">          reduction_data{section_id, 1};</div>
<div class="line">      <span class="comment">// Reduce over the section and broadcast to the full array</span></div>
<div class="line">      <span class="keyword">auto</span>&amp; array_proxy =</div>
<div class="line">          Parallel::get_parallel_component&lt;ParallelComponent&gt;(cache);</div>
<div class="line">      Parallel::contribute_to_reduction&lt;ReceiveCount&lt;ArraySectionIdTag&gt;&gt;(</div>
<div class="line">          std::move(reduction_data), array_proxy[array_index], array_proxy,</div>
<div class="line">          make_not_null(&amp;*array_section));</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__DataBoxGroup_html_gac94b70fab454bd5ae3b218f0ed182684"><div class="ttname"><a href="group__DataBoxGroup.html#gac94b70fab454bd5ae3b218f0ed182684">db::get_mutable_reference</a></div><div class="ttdeci">auto &amp; get_mutable_reference(const gsl::not_null&lt; DataBox&lt; TagList &gt; * &gt; box)</div><div class="ttdoc">Retrieve a mutable reference to the item with tag Tag from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:888</div></div>
<div class="ttc" id="astructParallel_1_1ReductionDatum_html"><div class="ttname"><a href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum</a></div><div class="ttdoc">The data to be reduced, and invokables to be called whenever two reduction messages are combined and ...</div><div class="ttdef"><b>Definition:</b> Reduction.hpp:64</div></div>
<div class="ttc" id="astructParallel_1_1Tags_1_1Section_html"><div class="ttname"><a href="structParallel_1_1Tags_1_1Section.html">Parallel::Tags::Section</a></div><div class="ttdoc">The Parallel::Section&lt;ParallelComponent, SectionIdTag&gt; that this element belongs to.</div><div class="ttdef"><b>Definition:</b> Section.hpp:29</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structParallel_1_1Section.html" title="A subset of chares in a parallel component.">Section</a> reductions currently don't support migrating elements, i.e. either load-balancing or restoring a checkpoint to a different number of PEs. Support for migrating elements may require <a href="https://charm.readthedocs.io/en/latest/charm++/manual.html#section-operations-with-migrating-elements">updating the "section cookie"</a>. One possibility to update the section cookie is to broadcast a CkMulticast message to the section elements and invoke <code>CkGetSectionInfo</code> within the message. </dd></dl>

</div>
</div>
<a id="ga3479433cebc81e70d646c6c755b47e1d" name="ga3479433cebc81e70d646c6c755b47e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3479433cebc81e70d646c6c755b47e1d">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fb3864413e851ea6dcd1ffa319f2f25" name="ga6fb3864413e851ea6dcd1ffa319f2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43c98b994ca4a6ef61235109c5b94e14" name="ga43c98b994ca4a6ef61235109c5b94e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c98b994ca4a6ef61235109c5b94e14">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const GlobalCache_detail::type_for_get&lt;GlobalCacheTag, Metavariables&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access data in the cache. </p>
<p ><em>Requires:</em> GlobalCacheTag is a tag in the <code>mutable_global_cache_tags</code> or <code>const_global_cache_tags</code> defined by the Metavariables and in Actions.</p>
<p ><em>Returns:</em> a constant reference to an object in the cache </p>

</div>
</div>
<a id="ga8c24e9812c22ee923354a3906e50f296" name="ga8c24e9812c22ee923354a3906e50f296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c24e9812c22ee923354a3906e50f296">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const Parallel::proxy_from_parallel_component&lt;
        GlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p ><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p ><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="gaeee02b1e4faf8051fe703e6b9adada0f" name="gaeee02b1e4faf8051fe703e6b9adada0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee02b1e4faf8051fe703e6b9adada0f">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; Parallel::proxy_from_parallel_component&lt;
        GlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p ><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p ><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="gaee973d82ab6a1dbac2b504e86d8de2e5" name="gaee973d82ab6a1dbac2b504e86d8de2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee973d82ab6a1dbac2b504e86d8de2e5">&#9670;&nbsp;</a></span>mutable_cache_item_is_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Function , typename Metavariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Parallel::mutable_cache_item_is_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object identified by <code>GlobalCacheTag</code> is ready to be accessed by <code>get</code>. </p>
<p ><em>Requires:</em> <code>GlobalCacheTag</code> is a tag in <code>mutable_global_cache_tags</code> defined by the Metavariables and in Actions.</p>
<p ><em>Requires:</em> <code>function</code> is a user-defined invokable that takes one argument: a const reference to the object referred to by the <code>GlobalCacheTag</code>. <code>function</code> returns a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;CallBack&gt;</code> that determines the readiness. To indicate that the item is ready, the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returned by <code>function</code> must be nullptr; in this case <code>mutable_cache_item_is_ready</code> returns true. To indicate that the item is not ready, the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returned by <code>function</code> must be valid; in this case, <code>mutable_cache_item_is_ready</code> appends the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classParallel_1_1Callback.html" title="An abstract base class, whose derived class holds a function that can be invoked at a later time....">Callback</a>&gt;</code> to an internal list of callbacks to be called on <code>mutate</code>, and then returns false. </p>

</div>
</div>
<a id="ga9a6490a57edb52d447ca1b7fa83b2175" name="ga9a6490a57edb52d447ca1b7fa83b2175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a6490a57edb52d447ca1b7fa83b2175">&#9670;&nbsp;</a></span>mutate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::mutate </td>
          <td>(</td>
          <td class="paramtype">CProxy_GlobalCache&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache_proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutates non-const data in the cache, by calling <code>Function::apply()</code> </p>
<p ><em>Requires:</em> <code>GlobalCacheTag</code> is a tag in tag_list. </p>
<p ><em>Requires:</em> <code>Function</code> is a struct with a static void <code><a class="el" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db" title="Apply the function object f using its nested argument_tags list of tags.">apply()</a></code> function that mutates the object. <code>Function::apply()</code> takes as its first argument a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> pointer to the object named by the <code>GlobalCacheTag</code>, and takes <code>args</code> as subsequent arguments.</p>
<p >This is the version that takes a charm++ proxy to the <a class="el" href="classParallel_1_1GlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node or non-constant data once per Charm++...">GlobalCache</a>. </p>

</div>
</div>
<a id="ga8fb8fc6f30581c450abecc8258dead3c" name="ga8fb8fc6f30581c450abecc8258dead3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb8fc6f30581c450abecc8258dead3c">&#9670;&nbsp;</a></span>mutate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GlobalCacheTag , typename Function , typename Metavariables , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1GlobalCache.html">GlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutates non-const data in the cache, by calling <code>Function::apply()</code> </p>
<p ><em>Requires:</em> <code>GlobalCacheTag</code> is a tag in the <code>mutable_global_cache_tags</code> defined by the Metavariables and in Actions. </p>
<p ><em>Requires:</em> <code>Function</code> is a struct with a static void <code><a class="el" href="group__DataStructuresGroup.html#ga058ade0497757606713948256728c6db" title="Apply the function object f using its nested argument_tags list of tags.">apply()</a></code> function that mutates the object. <code>Function::apply()</code> takes as its first argument a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> pointer to the object named by the <code>GlobalCacheTag</code>, and takes <code>args</code> as subsequent arguments.</p>
<p >This is the version that takes a GlobalCache&lt;Metavariables&gt;. Used only for tests. </p>

</div>
</div>
<a id="gae21964b5d28608afd21ae090c1c4c073" name="gae21964b5d28608afd21ae090c1c4c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21964b5d28608afd21ae090c1c4c073">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stdout with C printf usage. </p>
<p >Similar to Python, you can print any object that's streamable by passing it in as an argument and using the formatter "%s". For example, </p><div class="fragment"><div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a> a{0.8, 73, 9.8};</div>
<div class="line"><a class="code hl_function" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%s\n&quot;</span>, a);</div>
<div class="ttc" id="agroup__ParallelGroup_html_gae21964b5d28608afd21ae090c1c4c073"><div class="ttname"><a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a></div><div class="ttdeci">void printf(const std::string &amp;format, Args &amp;&amp;... args)</div><div class="ttdoc">Print an atomic message to stdout with C printf usage.</div><div class="ttdef"><b>Definition:</b> Printf.hpp:103</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa8448205dbaf9741505bd30dfad2cadc" name="gaa8448205dbaf9741505bd30dfad2cadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8448205dbaf9741505bd30dfad2cadc">&#9670;&nbsp;</a></span>printf_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stderr with C printf usage. </p>
<p >See <a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073" title="Print an atomic message to stdout with C printf usage.">Parallel::printf</a> for details. </p>

</div>
</div>
<a id="gad1078fa99233851c6475fbfa99a2f51d" name="gad1078fa99233851c6475fbfa99a2f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1078fa99233851c6475fbfa99a2f51d">&#9670;&nbsp;</a></span>receive_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::receive_data </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReceiveTag::temporal_id&#160;</td>
          <td class="paramname"><em>temporal_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReceiveDataType &amp;&amp;&#160;</td>
          <td class="paramname"><em>receive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_if_disabled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>. </p>
<p >If the algorithm was previously disabled, set <code>enable_if_disabled</code> to true to enable the algorithm on the parallel component. </p>

</div>
</div>
<a id="ga313d201814db8c6e1c64fce9384276a3" name="ga313d201814db8c6e1c64fce9384276a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga313d201814db8c6e1c64fce9384276a3">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt; serialize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object using PUP. </p>
<p >The type to serialize as must be explicitly specified. We require this because a mismatch between the serialize and deserialize calls causes undefined behavior and we do not want this to depend on inferred types for safety.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to serialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
