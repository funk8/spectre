<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: TensorExpressions Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.01.03</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceTensorExpressions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">TensorExpressions Namespace Reference<div class="ingroups"><a class="el" href="group__TensorExpressionsGroup.html">Tensor Expressions</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1AddSub.html">AddSub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsLie50499b100ea0125a8cc24bbdb8a6f38.html">AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1Divide.html">Divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the quotient of one tensor expression divided by another tensor expression that evaluates to a rank 0 tensor.  <a href="structTensorExpressions_1_1Divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1LhsTensorSymmAndIndices.html">LhsTensorSymmAndIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines and stores a LHS tensor's symmetry and index list from a RHS tensor expression and desired LHS index order.  <a href="structTensorExpressions_1_1LhsTensorSymmAndIndices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>LhsTensorSymmAndIndices&lt; tmpl::list&lt; RhsTensorIndices... &gt;, tmpl::list&lt; LhsTensorIndices... &gt;, tmpl::integral_list&lt; std::int32_t, RhsSymm... &gt;, RhsTensorIndexTypeList, NumLhsIndices, NumRhsIndices, std::index_sequence&lt; LhsInts... &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1Negate.html">Negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the negation of a tensor expression.  <a href="structTensorExpressions_1_1Negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1NumberAsExpression.html">NumberAsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a <code>double</code>  <a href="structTensorExpressions_1_1NumberAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1OuterProduct.html">OuterProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the outer product of two tensor expressions.  <a href="structTensorExpressions_1_1OuterProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1OuterProduct_3_01T1_00_01T2_00_01IndexList1_3_01Indices1_8_8_8_01_4_052cad3ba2c72111878d27a9309ec761e.html">OuterProduct&lt; T1, T2, IndexList1&lt; Indices1... &gt;, IndexList2&lt; Indices2... &gt;, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1SquareRoot.html">SquareRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor.  <a href="structTensorExpressions_1_1SquareRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1TensorAsExpression.html">TensorAsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a Tensor.  <a href="structTensorExpressions_1_1TensorAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1TensorAsExpression_3_01Tensor_3_01X_00_01Symm_00_01IndexList_3_01Indid64d2973d70682ce3b9f26b167087463.html">TensorAsExpression&lt; Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;, ArgsList&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1TensorContract.html">TensorContract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1tensorindex__list__is__valid.html">tensorindex_list_is_valid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not a given list of TensorIndexs is valid to be used with a tensor.  <a href="structTensorExpressions_1_1tensorindex__list__is__valid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1tensorindex__list__is__valid_3_01tmpl_1_1list_3_01TensorIndices_8_8_8_01_4_01_4.html">tensorindex_list_is_valid&lt; tmpl::list&lt; TensorIndices... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexList1 , typename TensorIndexList2 &gt; </td></tr>
<tr class="memitem:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga7ec89f154fa96d53979e1dde688eacdd">generic_indices_at_same_positions</a> = typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt; TensorIndexList1 &gt;::value==tmpl::size&lt; TensorIndexList2 &gt;::value &gt;::type</td></tr>
<tr class="memdesc:ga7ec89f154fa96d53979e1dde688eacdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not two lists of TensorIndexs contain the same generic indices at the same positions.  <a href="group__TensorExpressionsGroup.html#ga7ec89f154fa96d53979e1dde688eacdd">More...</a><br /></td></tr>
<tr class="separator:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf1f47693b43918b2059d945e7d420fb"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </td></tr>
<tr class="memitem:gabf1f47693b43918b2059d945e7d420fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gabf1f47693b43918b2059d945e7d420fb">evaluate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const TensorExpression&lt; Derived, X, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:gabf1f47693b43918b2059d945e7d420fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#gabf1f47693b43918b2059d945e7d420fb">More...</a><br /></td></tr>
<tr class="separator:gabf1f47693b43918b2059d945e7d420fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c617aa6645bc71d61662c87d51929f"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename RhsTE , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_base_of_v&lt; <a class="el" href="structExpression.html">Expression</a>, RhsTE &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gad7c617aa6645bc71d61662c87d51929f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gad7c617aa6645bc71d61662c87d51929f">evaluate</a> (const RhsTE &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:gad7c617aa6645bc71d61662c87d51929f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#gad7c617aa6645bc71d61662c87d51929f">More...</a><br /></td></tr>
<tr class="separator:gad7c617aa6645bc71d61662c87d51929f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816465178074d06f12a97633c0023ce1"><td class="memTemplParams" colspan="2">template&lt;size_t NumIndices1, size_t NumIndices2&gt; </td></tr>
<tr class="memitem:a816465178074d06f12a97633c0023ce1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorExpressions.html#a816465178074d06f12a97633c0023ce1">compute_tensorindex_transformation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices1 &gt; &amp;tensorindices1, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices2 &gt; &amp;tensorindices2)</td></tr>
<tr class="memdesc:a816465178074d06f12a97633c0023ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a transformation from one generic tensor index order to another.  <a href="namespaceTensorExpressions.html#a816465178074d06f12a97633c0023ce1">More...</a><br /></td></tr>
<tr class="separator:a816465178074d06f12a97633c0023ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505f9aa9acba11db8e5b1a7addee27f9"><td class="memTemplParams" colspan="2">template&lt;size_t NumIndicesIn, size_t NumIndicesOut&gt; </td></tr>
<tr class="memitem:a505f9aa9acba11db8e5b1a7addee27f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesOut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorExpressions.html#a505f9aa9acba11db8e5b1a7addee27f9">transform_multi_index</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesIn &gt; &amp;input_multi_index, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesOut &gt; &amp;tensorindex_transformation)</td></tr>
<tr class="memdesc:a505f9aa9acba11db8e5b1a7addee27f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the differences in their generic index orders.  <a href="namespaceTensorExpressions.html#a505f9aa9acba11db8e5b1a7addee27f9">More...</a><br /></td></tr>
<tr class="separator:a505f9aa9acba11db8e5b1a7addee27f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Holds all possible <a class="el" href="namespaceTensorExpressions.html">TensorExpressions</a> currently implemented </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a816465178074d06f12a97633c0023ce1" name="a816465178074d06f12a97633c0023ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816465178074d06f12a97633c0023ce1">&#9670;&nbsp;</a></span>compute_tensorindex_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumIndices1, size_t NumIndices2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices2 &gt; TensorExpressions::compute_tensorindex_transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensorindices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndices2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensorindices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a transformation from one generic tensor index order to another. </p>
<h3>Details</h3>
<p >In most cases, the elements of the transformation are simply the positions of the second list of generic indices in the first list of generic indices. Put another way, for some <code>i</code>, <code>tensorindices2[i] == tensorindices1[index_transformation[i]]</code>.</p>
<p >Here is an example of what the algorithm does:</p>
<p >Transformation between (1) \(R_{cab}\) and (2) \(S_{abc}\) <code>tensorindices1</code>: </p><div class="fragment"><div class="line">{2, 0, 1} <span class="comment">// TensorIndex values for {c, a, b}</span></div>
</div><!-- fragment --><p> <code>tensorindices2</code>: </p><div class="fragment"><div class="line">{0, 1, 2} <span class="comment">// TensorIndex values for {a, b, c}</span></div>
</div><!-- fragment --><p> returned <code>tensorindex_transformation</code>: </p><div class="fragment"><div class="line">{1, 2, 0} <span class="comment">// positions of S&#39; indices {a, b, c} in R&#39;s indices {c, a, b}</span></div>
</div><!-- fragment --><p >One special case scenario to note is when concrete time indices are involved in the transformation. Consider transforming a multi-index for some tensor \(R_{ab}\) to another tensor \(S_{btat}\). This would be necessary for evaluating the LHS of a simple equation such as \(R_{ab} = S_{btat}\). The transformation between a multi-index for \(R\) to the equivalent multi-index for \(S\) cannot simply be the list of positions of \(S\)' indices in \(R\)'s indices, as \(R\) does not contain all of \(S\)' indices, because it has no time indices. To handle cases like this, a placeholder value for the position of any time index is substituted for an actual position, since one may not exist. In this example, the transformation would be <code>{1, PLACEHOLDER_VALUE, 0, PLACEHOLDER_VALUE}</code>, where <code>PLACEHOLDER_VALUE</code> is defined by <code>TensorIndexTransformation_detail::time_index_position_placeholder</code>. <code>1</code> and <code>0</code> are the positions of \(b\) and \(a\) in \(R\), and the placeholder is used for the positions of time indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumIndices1</td><td>the number of indices for the first generic index order </td></tr>
    <tr><td class="paramname">NumIndices2</td><td>the number of indices for the second generic index order </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindices1</td><td>the <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> values of the first generic index order </td></tr>
    <tr><td class="paramname">tensorindices2</td><td>the <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> values of the second generic index order </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> a transformation from the first generic index order to the second </p>

</div>
</div>
<a id="a505f9aa9acba11db8e5b1a7addee27f9" name="a505f9aa9acba11db8e5b1a7addee27f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505f9aa9acba11db8e5b1a7addee27f9">&#9670;&nbsp;</a></span>transform_multi_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumIndicesIn, size_t NumIndicesOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesOut &gt; TensorExpressions::transform_multi_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, NumIndicesOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tensor multi-index that is equivalent to a given tensor multi-index, according to the differences in their generic index orders. </p>
<h3>Details</h3>
<p >Here is an example of what the algorithm does:</p>
<p >Transform (input) multi-index of \(R_{cab}\) to the equivalent (output) multi-index of \(S_{abc}\) <code>tensorindex_transformation</code>: </p><div class="fragment"><div class="line">{1, 2, 0} <span class="comment">// positions of S&#39; indices {a, b, c} in R&#39;s indices {c, a, b}</span></div>
</div><!-- fragment --><p> <code>input_multi_index</code>: </p><div class="fragment"><div class="line">{3, 4, 5} <span class="comment">// i.e. c = 3, a = 4, b = 5</span></div>
</div><!-- fragment --><p> returned equivalent <code>output_multi_index</code>: </p><div class="fragment"><div class="line">{4, 5, 3} <span class="comment">// i.e. a = 4, b = 5, c = 3</span></div>
</div><!-- fragment --><p >One special case scenario to note is when concrete time indices are involved in the transformation. Consider transforming a multi-index for some tensor \(R_{ab}\) to another tensor \(S_{btat}\). This would be necessary for evaluating the LHS of a simple equation such as \(R_{ab} = S_{btat}\). The transformation between a multi-index for \(R\) to the equivalent multi-index for \(S\) cannot simply be the list of positions of \(S\)' indices in \(R\)'s indices, as \(R\) does not contain all of \(S\)' indices, because it has no time indices. To handle cases like this, a placeholder value for the position of any time index must be substituted for an actual position, since one may not exist. In this example, the proper input transformation (<code>tensorindex_transformation</code>) would need to be <code>{1, PLACEHOLDER_VALUE, 0, PLACEHOLDER_VALUE}</code>, where <code>PLACEHOLDER_VALUE</code> is defined by <code>TensorIndexTransformation_detail::time_index_position_placeholder</code>. <code>1</code> and <code>0</code> are the positions of \(b\) and \(a\) in \(R\), and the placeholder is used for the positions of time indices. In computing the output transformed multi-index, the function will insert a <code>0</code> at each position where this placeholder is found in the transformation. For example, if <code>input_multi_index</code> is <code>{1, 2}</code>, representing \(R_{12}\), the returned output multi-index will be <code>{2, 0, 1, 0}</code>, representing \(S_{2010}\).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumIndicesIn</td><td>the number of indices </td></tr>
    <tr><td class="paramname">NumIndicesOut</td><td>the number of indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_multi_index</td><td>the input tensor multi-index to transform </td></tr>
    <tr><td class="paramname">tensorindex_transformation</td><td>the positions of the output's generic indices in the input's generic indices (see example in details) </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the output tensor multi-index that is equivalent to <code>input_multi_index</code>, according to generic index order differences </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceTensorExpressions.html">TensorExpressions</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
