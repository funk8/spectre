<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.9.3"/>
  <title>SpECTRE: Tensor Expressions</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script type="text/javascript" src="spectre.js"></script>
  <script type="text/javascript" src="doxygen-navtree-hacks.js"></script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">SpECTRE</a>
              &#160;<span id="projectnumber">v2022.01.03</span>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TensorExpressionsGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Tensor Expressions</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTensorExpressions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTensorExpressions.html">TensorExpressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1TensorContract.html">TensorExpressions::TensorContract&lt; FirstContractedIndexPos, SecondContractedIndexPos, T, X, Symm, IndexList, ArgsList &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1Divide.html">TensorExpressions::Divide&lt; T1, T2, Args2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the quotient of one tensor expression divided by another tensor expression that evaluates to a rank 0 tensor.  <a href="structTensorExpressions_1_1Divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1LhsTensorSymmAndIndices.html">TensorExpressions::LhsTensorSymmAndIndices&lt; RhsTensorIndexList, LhsTensorIndexList, RhsSymmetry, RhsTensorIndexTypeList, NumLhsIndices, NumRhsIndices, LhsIndexSequence &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines and stores a LHS tensor's symmetry and index list from a RHS tensor expression and desired LHS index order.  <a href="structTensorExpressions_1_1LhsTensorSymmAndIndices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1Negate.html">TensorExpressions::Negate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the negation of a tensor expression.  <a href="structTensorExpressions_1_1Negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1NumberAsExpression.html">TensorExpressions::NumberAsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a <code>double</code>  <a href="structTensorExpressions_1_1NumberAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1OuterProduct.html">TensorExpressions::OuterProduct&lt; T1, T2, IndexList1, IndexList2, ArgsList1, ArgsList2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the outer product of two tensor expressions.  <a href="structTensorExpressions_1_1OuterProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1SquareRoot.html">TensorExpressions::SquareRoot&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor.  <a href="structTensorExpressions_1_1SquareRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1TensorAsExpression.html">TensorExpressions::TensorAsExpression&lt; T, ArgsList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an expression representing a Tensor.  <a href="structTensorExpressions_1_1TensorAsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExpression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a class as being a TensorExpression.  <a href="structExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html">TensorExpression&lt; Derived, DataType, Symm, tmpl::list&lt; Indices... &gt;, ArgsList&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class all tensor expression implementations derive from.  <a href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01tmpl_1_1list_3_01Indices_8_8_8_0325e1bafc70f036ee2f18c4f6a988515.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorIndex.html">TensorIndex&lt; I, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the geeric indices in a TensorExpression.  <a href="structTensorIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__tensor__index.html">tt::is_tensor_index&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type <code>T</code> is a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> used in <a class="el" href="namespaceTensorExpressions.html">TensorExpressions</a>.  <a href="structtt_1_1is__tensor__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorExpressions_1_1tensorindex__list__is__valid.html">TensorExpressions::tensorindex_list_is_valid&lt; TensorIndexList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not a given list of TensorIndexs is valid to be used with a tensor.  <a href="structTensorExpressions_1_1tensorindex__list__is__valid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1is__time__index.html">tt::is_time_index&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type <code>T</code> is a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> representing a concrete time index.  <a href="structtt_1_1is__time__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memTemplParams" colspan="2">template&lt;typename TensorIndexList1 , typename TensorIndexList2 &gt; </td></tr>
<tr class="memitem:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga7ec89f154fa96d53979e1dde688eacdd">TensorExpressions::generic_indices_at_same_positions</a> = typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt; TensorIndexList1 &gt;::value==tmpl::size&lt; TensorIndexList2 &gt;::value &gt;::type</td></tr>
<tr class="memdesc:ga7ec89f154fa96d53979e1dde688eacdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not two lists of TensorIndexs contain the same generic indices at the same positions.  <a href="group__TensorExpressionsGroup.html#ga7ec89f154fa96d53979e1dde688eacdd">More...</a><br /></td></tr>
<tr class="separator:ga7ec89f154fa96d53979e1dde688eacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e3e652d1c21055d20584e8531cdfc8"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... TensorIndices&gt; </td></tr>
<tr class="memitem:gab1e3e652d1c21055d20584e8531cdfc8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gab1e3e652d1c21055d20584e8531cdfc8">make_tensorindex_list</a> = typename TensorExpressions::detail::make_tensorindex_list_impl&lt; TensorIndices... &gt;::type</td></tr>
<tr class="memdesc:gab1e3e652d1c21055d20584e8531cdfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> type list from a list of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> objects.  <a href="group__TensorExpressionsGroup.html#gab1e3e652d1c21055d20584e8531cdfc8">More...</a><br /></td></tr>
<tr class="separator:gab1e3e652d1c21055d20584e8531cdfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memTemplParams" colspan="2"><a id="ga702fc5dbc87cb179f0868e9ce9ff22dd" name="ga702fc5dbc87cb179f0868e9ce9ff22dd"></a>
template&lt;typename T1 , typename T2 , typename X1 , typename X2 , typename Symm1 , typename Symm2 , typename IndexList1 , typename IndexList2 , typename Args1 , typename Args2 &gt; </td></tr>
<tr class="memitem:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const TensorExpression&lt; T1, X1, Symm1, IndexList1, Args1 &gt; &amp;t1, const TensorExpression&lt; T2, X2, Symm2, IndexList2, Args2 &gt; &amp;t2)</td></tr>
<tr class="separator:ga702fc5dbc87cb179f0868e9ce9ff22dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15727391dd98d3862c08b543eed1dde"><td class="memTemplParams" colspan="2"><a id="gad15727391dd98d3862c08b543eed1dde" name="gad15727391dd98d3862c08b543eed1dde"></a>
template&lt;typename T1 , typename T2 , typename X1 , typename X2 , typename Symm1 , typename Symm2 , typename IndexList1 , typename IndexList2 , typename Args1 , typename Args2 &gt; </td></tr>
<tr class="memitem:gad15727391dd98d3862c08b543eed1dde"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const TensorExpression&lt; T1, X1, Symm1, IndexList1, Args1 &gt; &amp;t1, const TensorExpression&lt; T2, X2, Symm2, IndexList2, Args2 &gt; &amp;t2)</td></tr>
<tr class="separator:gad15727391dd98d3862c08b543eed1dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762436e7479597dc0ebf379d22a068ef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Args2&gt; </td></tr>
<tr class="memitem:ga762436e7479597dc0ebf379d22a068ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga762436e7479597dc0ebf379d22a068ef">operator/</a> (const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, typename T1::args_list &gt; &amp;t1, const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, tmpl::list&lt; Args2... &gt; &gt; &amp;t2)</td></tr>
<tr class="memdesc:ga762436e7479597dc0ebf379d22a068ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of one tensor expression over another tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#ga762436e7479597dc0ebf379d22a068ef">More...</a><br /></td></tr>
<tr class="separator:ga762436e7479597dc0ebf379d22a068ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38ac6d56dab868993256c3041ae4b9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae38ac6d56dab868993256c3041ae4b9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gae38ac6d56dab868993256c3041ae4b9e">operator/</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t, const double number)</td></tr>
<tr class="memdesc:gae38ac6d56dab868993256c3041ae4b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a tensor expression over a <code>double</code>  <a href="group__TensorExpressionsGroup.html#gae38ac6d56dab868993256c3041ae4b9e">More...</a><br /></td></tr>
<tr class="separator:gae38ac6d56dab868993256c3041ae4b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166783bb4abd271213f364af9d1fe85e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga166783bb4abd271213f364af9d1fe85e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga166783bb4abd271213f364af9d1fe85e">operator/</a> (const double number, const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:ga166783bb4abd271213f364af9d1fe85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the quotient of a <code>double</code> over a tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#ga166783bb4abd271213f364af9d1fe85e">More...</a><br /></td></tr>
<tr class="separator:ga166783bb4abd271213f364af9d1fe85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1f47693b43918b2059d945e7d420fb"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </td></tr>
<tr class="memitem:gabf1f47693b43918b2059d945e7d420fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gabf1f47693b43918b2059d945e7d420fb">TensorExpressions::evaluate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt; lhs_tensor, const TensorExpression&lt; Derived, X, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:gabf1f47693b43918b2059d945e7d420fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#gabf1f47693b43918b2059d945e7d420fb">More...</a><br /></td></tr>
<tr class="separator:gabf1f47693b43918b2059d945e7d420fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c617aa6645bc71d61662c87d51929f"><td class="memTemplParams" colspan="2">template&lt;auto &amp;... LhsTensorIndices, typename RhsTE , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_base_of_v&lt; <a class="el" href="structExpression.html">Expression</a>, RhsTE &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gad7c617aa6645bc71d61662c87d51929f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gad7c617aa6645bc71d61662c87d51929f">TensorExpressions::evaluate</a> (const RhsTE &amp;rhs_tensorexpression)</td></tr>
<tr class="memdesc:gad7c617aa6645bc71d61662c87d51929f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters.  <a href="group__TensorExpressionsGroup.html#gad7c617aa6645bc71d61662c87d51929f">More...</a><br /></td></tr>
<tr class="separator:gad7c617aa6645bc71d61662c87d51929f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762efb87d8c1cc6996202f848588994f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga762efb87d8c1cc6996202f848588994f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga762efb87d8c1cc6996202f848588994f">operator-</a> (const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;t)</td></tr>
<tr class="memdesc:ga762efb87d8c1cc6996202f848588994f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the negation of a tensor expression.  <a href="group__TensorExpressionsGroup.html#ga762efb87d8c1cc6996202f848588994f">More...</a><br /></td></tr>
<tr class="separator:ga762efb87d8c1cc6996202f848588994f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078bcec08b0bef602762b194bf6ecb95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ArgsList1 , typename ArgsList2 &gt; </td></tr>
<tr class="memitem:ga078bcec08b0bef602762b194bf6ecb95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga078bcec08b0bef602762b194bf6ecb95">operator*</a> (const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, ArgsList1 &gt; &amp;t1, const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, ArgsList2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:ga078bcec08b0bef602762b194bf6ecb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of two tensor expressions.  <a href="group__TensorExpressionsGroup.html#ga078bcec08b0bef602762b194bf6ecb95">More...</a><br /></td></tr>
<tr class="separator:ga078bcec08b0bef602762b194bf6ecb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e742f6a0919a54715253d91318d7bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:ga68e742f6a0919a54715253d91318d7bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">sqrt</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:ga68e742f6a0919a54715253d91318d7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor.  <a href="group__TensorExpressionsGroup.html#ga68e742f6a0919a54715253d91318d7bb">More...</a><br /></td></tr>
<tr class="separator:ga68e742f6a0919a54715253d91318d7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4106ecd6e776ce1106f1d8f99f973f53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:ga4106ecd6e776ce1106f1d8f99f973f53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga4106ecd6e776ce1106f1d8f99f973f53">operator+</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const double number)</td></tr>
<tr class="memdesc:ga4106ecd6e776ce1106f1d8f99f973f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#ga4106ecd6e776ce1106f1d8f99f973f53">More...</a><br /></td></tr>
<tr class="separator:ga4106ecd6e776ce1106f1d8f99f973f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b896c7c7a6121e1ff6bb6ee4796f49"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:gae2b896c7c7a6121e1ff6bb6ee4796f49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#gae2b896c7c7a6121e1ff6bb6ee4796f49">operator+</a> (const double number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:gae2b896c7c7a6121e1ff6bb6ee4796f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the sum of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#gae2b896c7c7a6121e1ff6bb6ee4796f49">More...</a><br /></td></tr>
<tr class="separator:gae2b896c7c7a6121e1ff6bb6ee4796f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e7bc480bc6326195be81b6bc4f76c5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:ga24e7bc480bc6326195be81b6bc4f76c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga24e7bc480bc6326195be81b6bc4f76c5">operator-</a> (const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t, const double number)</td></tr>
<tr class="memdesc:ga24e7bc480bc6326195be81b6bc4f76c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#ga24e7bc480bc6326195be81b6bc4f76c5">More...</a><br /></td></tr>
<tr class="separator:ga24e7bc480bc6326195be81b6bc4f76c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cc4d5f62bdce21f15351d4fef2e547"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </td></tr>
<tr class="memitem:ga56cc4d5f62bdce21f15351d4fef2e547"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga56cc4d5f62bdce21f15351d4fef2e547">operator-</a> (const double number, const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;t)</td></tr>
<tr class="memdesc:ga56cc4d5f62bdce21f15351d4fef2e547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the difference of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#ga56cc4d5f62bdce21f15351d4fef2e547">More...</a><br /></td></tr>
<tr class="separator:ga56cc4d5f62bdce21f15351d4fef2e547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5391a3346aee013115d63e30da7bfbbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename ArgsList &gt; </td></tr>
<tr class="memitem:ga5391a3346aee013115d63e30da7bfbbc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga5391a3346aee013115d63e30da7bfbbc">operator*</a> (const TensorExpression&lt; T, X, typename T::symmetry, typename T::index_list, ArgsList &gt; &amp;t, const double number)</td></tr>
<tr class="memdesc:ga5391a3346aee013115d63e30da7bfbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#ga5391a3346aee013115d63e30da7bfbbc">More...</a><br /></td></tr>
<tr class="separator:ga5391a3346aee013115d63e30da7bfbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86500da21daadbc6454d0385055bdac5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename ArgsList &gt; </td></tr>
<tr class="memitem:ga86500da21daadbc6454d0385055bdac5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorExpressionsGroup.html#ga86500da21daadbc6454d0385055bdac5">operator*</a> (const double number, const TensorExpression&lt; T, X, typename T::symmetry, typename T::index_list, ArgsList &gt; &amp;t)</td></tr>
<tr class="memdesc:ga86500da21daadbc6454d0385055bdac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor expression representing the product of a tensor expression and a <code>double</code>  <a href="group__TensorExpressionsGroup.html#ga86500da21daadbc6454d0385055bdac5">More...</a><br /></td></tr>
<tr class="separator:ga86500da21daadbc6454d0385055bdac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Tensor Expressions allow writing expressions of tensors in a way similar to what is used with pen and paper.</p>
<p >Tensor expressions are implemented using (smart) expression templates. This allows a domain specific language making expressions such as </p><div class="fragment"><div class="line"><span class="keyword">auto</span> T = evaluate&lt;Indices::_a_t, Indices::_b_t&gt;(F(Indices::_b,</div>
<div class="line">Indices::_a));</div>
</div><!-- fragment --><p> possible. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga7ec89f154fa96d53979e1dde688eacdd" name="ga7ec89f154fa96d53979e1dde688eacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec89f154fa96d53979e1dde688eacdd">&#9670;&nbsp;</a></span>generic_indices_at_same_positions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorIndexList1 , typename TensorIndexList2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorExpressionsGroup.html#ga7ec89f154fa96d53979e1dde688eacdd">TensorExpressions::generic_indices_at_same_positions</a> = typedef typename detail::generic_indices_at_same_positions_impl&lt; TensorIndexList1, TensorIndexList2, tmpl::size&lt;TensorIndexList1&gt;::value == tmpl::size&lt;TensorIndexList2&gt;::value&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether or not two lists of TensorIndexs contain the same generic indices at the same positions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndexList1</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> list </td></tr>
    <tr><td class="paramname">TensorIndexList2</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1e3e652d1c21055d20584e8531cdfc8" name="gab1e3e652d1c21055d20584e8531cdfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e3e652d1c21055d20584e8531cdfc8">&#9670;&nbsp;</a></span>make_tensorindex_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... TensorIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TensorExpressionsGroup.html#gab1e3e652d1c21055d20584e8531cdfc8">make_tensorindex_list</a> =  typename TensorExpressions::detail::make_tensorindex_list_impl&lt; TensorIndices...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> type list from a list of <a class="el" href="structTensorIndex.html" title="Represents the geeric indices in a TensorExpression.">TensorIndex</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorIndices</td><td>list of generic index objects, e.g. <code>ti_a, ti_b</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabf1f47693b43918b2059d945e7d420fb" name="gabf1f47693b43918b2059d945e7d420fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf1f47693b43918b2059d945e7d420fb">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename X , typename LhsSymmetry , typename LhsIndexList , typename Derived , typename RhsSymmetry , typename RhsIndexList , typename... RhsTensorIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TensorExpressions::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Tensor&lt; X, LhsSymmetry, LhsIndexList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>lhs_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; Derived, X, RhsSymmetry, RhsIndexList, tmpl::list&lt; RhsTensorIndices... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_tensorexpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Uses the right hand side (RHS) TensorExpression's index ordering (<code>RhsTE::args_list</code>) and the desired left hand side (LHS) tensor's index ordering (<code>LhsTensorIndices</code>) to fill the provided LHS Tensor with that LHS index ordering. This can carry out the evaluation of a RHS tensor expression to a LHS tensor with the same index ordering, such as \(L_{ab} = R_{ab}\), or different ordering, such as \(L_{ba} = R_{ab}\).</p>
<p >The symmetry of the provided LHS Tensor need not match the symmetry determined from evaluating the RHS TensorExpression according to its order of operations. This allows one to specify LHS symmetries (via <code>lhs_tensor</code>) that may not be preserved by the RHS expression's order of operations, which depends on how the expression is written and implemented.</p>
<h3><a class="anchor" id="autotoc_md177"></a>
Example usage</h3>
<p >Given two rank 2 Tensors <code>R</code> and <code>S</code> with index order (a, b), add them together and fill the provided resultant LHS Tensor <code>L</code> with index order (b, a): </p><div class="fragment"><div class="line">TensorExpressions::evaluate&lt;ti_b, ti_a&gt;(</div>
<div class="line">    make_not_null(&amp;L), R(ti_a, ti_b) + S(ti_a, ti_b));</div>
</div><!-- fragment --><p >This represents evaluating: \(L_{ba} = R_{ab} + S_{ab}\)</p>
<p >Note: <code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the TensorIndexs of the Tensor on the LHS of the tensor expression, e.g. <code>ti_a</code>, <code>ti_b</code>, <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs_tensor</td><td>pointer to the resultant LHS Tensor to fill </td></tr>
    <tr><td class="paramname">rhs_tensorexpression</td><td>the RHS TensorExpression to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7c617aa6645bc71d61662c87d51929f" name="gad7c617aa6645bc71d61662c87d51929f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7c617aa6645bc71d61662c87d51929f">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp;... LhsTensorIndices, typename RhsTE , <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a>&lt; std::is_base_of_v&lt; <a class="el" href="structExpression.html">Expression</a>, RhsTE &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TensorExpressions::evaluate </td>
          <td>(</td>
          <td class="paramtype">const RhsTE &amp;&#160;</td>
          <td class="paramname"><em>rhs_tensorexpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a RHS tensor expression to a tensor with the LHS index order set in the template parameters. </p>
<h3>Details</h3>
<p >Uses the right hand side (RHS) TensorExpression's index ordering (<code>RhsTE::args_list</code>) and the desired left hand side (LHS) tensor's index ordering (<code>LhsTensorIndices</code>) to construct a LHS Tensor with that LHS index ordering. This can carry out the evaluation of a RHS tensor expression to a LHS tensor with the same index ordering, such as \(L_{ab} = R_{ab}\), or different ordering, such as \(L_{ba} = R_{ab}\).</p>
<p >The symmetry of the returned LHS Tensor depends on the order of operations in the RHS TensorExpression, i.e. how the expression is written. If you would like to specify the symmetry of the LHS Tensor instead of it being determined by the order of operations in the RHS expression, please use the other <code>evaluate</code> overload that takes an empty LHS Tensor as its first argument.</p>
<h3><a class="anchor" id="autotoc_md178"></a>
Example usage</h3>
<p >Given two rank 2 Tensors <code>R</code> and <code>S</code> with index order (a, b), add them together and generate the resultant LHS Tensor <code>L</code> with index order (b, a): </p><div class="fragment"><div class="line"><span class="keyword">auto</span> L = TensorExpressions::evaluate&lt;ti_b, ti_a&gt;(</div>
<div class="line">    R(ti_a, ti_b) + S(ti_a, ti_b));</div>
</div><!-- fragment --> <p ><em>Returns:</em> Tensor</p>
<p >This represents evaluating: \(L_{ba} = R_{ab} + S_{ab}\)</p>
<p >Note: If a generic spatial index is used for a spacetime index in the RHS tensor, its corresponding index in the LHS tensor type will be a spatial index with the same valence, frame, and number of spatial dimensions. If a concrete time index is used for a spacetime index in the RHS tensor, the index will not appear in the LHS tensor (i.e. there will NOT be a corresponding LHS index where only the time index of that index has been computed and its spatial indices are empty).</p>
<p >Note: <code>LhsTensorIndices</code> must be passed by reference because non-type template parameters cannot be class types until C++20.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsTensorIndices</td><td>the TensorIndexs of the Tensor on the LHS of the tensor expression, e.g. <code>ti_a</code>, <code>ti_b</code>, <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs_tensorexpression</td><td>the RHS TensorExpression to be evaluated </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the resultant LHS Tensor with index order specified by LhsTensorIndices </p>

</div>
</div>
<a id="ga86500da21daadbc6454d0385055bdac5" name="ga86500da21daadbc6454d0385055bdac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86500da21daadbc6454d0385055bdac5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename ArgsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, typename T::symmetry, typename T::index_list, ArgsList &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a <code>double</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">ArgsList</td><td>the TensorIndexs of the tensor expression operand of the product </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga5391a3346aee013115d63e30da7bfbbc" name="ga5391a3346aee013115d63e30da7bfbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5391a3346aee013115d63e30da7bfbbc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename ArgsList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, typename T::symmetry, typename T::index_list, ArgsList &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of a tensor expression and a <code>double</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">ArgsList</td><td>the TensorIndexs of the tensor expression operand of the product </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the product </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga078bcec08b0bef602762b194bf6ecb95" name="ga078bcec08b0bef602762b194bf6ecb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga078bcec08b0bef602762b194bf6ecb95">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ArgsList1 , typename ArgsList2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, ArgsList1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, ArgsList2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the product of two tensor expressions. </p>
<h3>Details</h3>
<p >If the two operands have N pairs of indices that need to be contracted, the returned expression will be an <code>OuterProduct</code> expression nested inside N <code>TensorContract</code> expressions. This represents computing the inner product of the outer product of the two operands. If the operands do not have any indices to be contracted, the returned expression will be an <code>OuterProduct</code>.</p>
<p >The two arguments are expressions that contain the two operands of the product, where the types of the operands are <code>T1</code> and <code>T2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>the derived TensorExpression type of the first operand of the product </td></tr>
    <tr><td class="paramname">T2</td><td>the derived TensorExpression type of the second operand of the product </td></tr>
    <tr><td class="paramname">ArgsList1</td><td>the TensorIndexs of the first operand </td></tr>
    <tr><td class="paramname">ArgsList2</td><td>the TensorIndexs of the second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>first operand expression of the product </td></tr>
    <tr><td class="paramname">t2</td><td>the second operand expression of the product </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the product of two tensor expressions </p>

</div>
</div>
<a id="gae2b896c7c7a6121e1ff6bb6ee4796f49" name="gae2b896c7c7a6121e1ff6bb6ee4796f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b896c7c7a6121e1ff6bb6ee4796f49">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a <code>double</code> </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">Symm</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">IndexList</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">Args</td><td>the comma-separated list of generic indices of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga4106ecd6e776ce1106f1d8f99f973f53" name="ga4106ecd6e776ce1106f1d8f99f973f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4106ecd6e776ce1106f1d8f99f973f53">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the sum of a tensor expression and a <code>double</code> </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">Symm</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">IndexList</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">Args</td><td>the comma-separated list of generic indices of the derived TensorExpression type of the tensor expression operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the sum </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the sum </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the sum of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga56cc4d5f62bdce21f15351d4fef2e547" name="ga56cc4d5f62bdce21f15351d4fef2e547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56cc4d5f62bdce21f15351d4fef2e547">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a <code>double</code> </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">Symm</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">IndexList</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">Args</td><td>the comma-separated list of generic indices of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga762efb87d8c1cc6996202f848588994f" name="ga762efb87d8c1cc6996202f848588994f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762efb87d8c1cc6996202f848588994f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the negation of a tensor expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the negation of <code>t</code> </p>

</div>
</div>
<a id="ga24e7bc480bc6326195be81b6bc4f76c5" name="ga24e7bc480bc6326195be81b6bc4f76c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e7bc480bc6326195be81b6bc4f76c5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the difference of a tensor expression and a <code>double</code> </p>
<h3>Details</h3>
<p >The tensor expression operand must represent an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that the tensor expression operand could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">X</td><td>the type of data stored in the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">Symm</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">IndexList</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">Args</td><td>the comma-separated list of generic indices of the derived TensorExpression type of the tensor expression operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the difference </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the difference </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the difference of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga166783bb4abd271213f364af9d1fe85e" name="ga166783bb4abd271213f364af9d1fe85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166783bb4abd271213f364af9d1fe85e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a <code>double</code> over a tensor expression that evaluates to a rank 0 tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>the <code>double</code> numerator of the quotient </td></tr>
    <tr><td class="paramname">t</td><td>the tensor expression denominator of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of a <code>double</code> over a tensor expression that evaluates to a rank 0 tensor </p>

</div>
</div>
<a id="gae38ac6d56dab868993256c3041ae4b9e" name="gae38ac6d56dab868993256c3041ae4b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38ac6d56dab868993256c3041ae4b9e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, typename T::type, typename T::symmetry, typename T::index_list, typename T::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of a tensor expression over a <code>double</code> </p>
<dl class="section note"><dt>Note</dt><dd>The implementation instead uses the operation, <code>t * (1.0 / number)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression operand of the quotient </td></tr>
    <tr><td class="paramname">number</td><td>the <code>double</code> operand of the quotient </td></tr>
  </table>
  </dd>
</dl>
<p ><em>Returns:</em> the tensor expression representing the quotient of a tensor expression and a <code>double</code> </p>

</div>
</div>
<a id="ga762436e7479597dc0ebf379d22a068ef" name="ga762436e7479597dc0ebf379d22a068ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762436e7479597dc0ebf379d22a068ef">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Args2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T1, typename T1::type, typename T1::symmetry, typename T1::index_list, typename T1::args_list &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorExpression&lt; T2, typename T2::type, typename T2::symmetry, typename T2::index_list, tmpl::list&lt; Args2... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the quotient of one tensor expression over another tensor expression that evaluates to a rank 0 tensor. </p>
<h3>Details</h3>
<p ><code>t2</code> must be an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that <code>t2</code> could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t) + 1.0</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>the tensor expression numerator </td></tr>
    <tr><td class="paramname">t2</td><td>the rank 0 tensor expression denominator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68e742f6a0919a54715253d91318d7bb" name="ga68e742f6a0919a54715253d91318d7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e742f6a0919a54715253d91318d7bb">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename Symm , typename IndexList , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sqrt </td>
          <td>(</td>
          <td class="paramtype">const TensorExpression&lt; T, X, Symm, IndexList, tmpl::list&lt; Args... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tensor expression representing the square root of a tensor expression that evaluates to a rank 0 tensor. </p>
<h3>Details</h3>
<p ><code>t</code> must be an expression that, when evaluated, would be a rank 0 tensor. For example, if <code>R</code> and <code>S</code> are Tensors, here is a non-exhaustive list of some of the acceptable forms that <code>t</code> could take:</p><ul>
<li><code>R()</code></li>
<li><code>R(ti_A, ti_a)</code></li>
<li><code>(R(ti_A, ti_B) * S(ti_a, ti_b))</code></li>
<li><code>R(ti_t, ti_t) + 1.0</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tensor expression of which to take the square root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2022
    <a href="https://black-holes.org">SXS Collaboration</a>,
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
